
//=====================================


require("./config")

const {
 BufferJSON, 
WA_DEFAULT_EPHEMERAL, 
downloadContentFromMessage, 
delay,
generateWAMessageFromContent, 
proto, 
generateWAMessageContent, 
WAProto, 
generateWAMessage, 
prepareWAMessageMedia, 
areJidsSameUser, 
getContentType, 
WAFlag 
} = require('@adiwajshing/baileys')


const zmans = require("@adiwajshing/baileys")
const uber = require('uberduck-api')
const fs = require('fs')
const yts = require('yt-search');
const util = require('util')
const chalk = require('chalk')
const { exec, spawn, execSync } = require("child_process")
const axios = require('axios')
const ffmpeg = require('fluent-ffmpeg');
const xa = require('xfarr-api')
const { Youtube } = require('ytdownloader.js')

const { mediafire } = require('./fun√ß√µes de cmd/fun√ß√µes/mediafire')

const {  imageToWebp, videoToWebp, writeExifImg, writeExifVid } = require('./fun√ß√µes/exif') 

const { pornok, hentai } = require('./fun√ß√µes de cmd/fun√ß√µes/scraper')

const webp_mp4 = require("./fun√ß√µes de cmd/fun√ß√µes/webp_mp4.js");

const { validmove, setGame } = require('./fun√ß√µes de cmd/tictactoe');

const execute = util.promisify(require('child_process').exec)

const { pinterest } = require("./fun√ß√µes de cmd/fun√ß√µes/pinterest")

const { wallpaper } = require("./fun√ß√µes de cmd/fun√ß√µes/wallpaper")

const sotoy = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/fun√ß√µes/sotoy.json'));

const autoreact = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/fun√ß√µes/autoreact.json'))

const { palavrasANA } = require('./fun√ß√µes de cmd/fun√ß√µes/jogos.js');

const { infobemvindo } = require('./fun√ß√µes de cmd/fun√ß√µes/infobv.js');

const welcome_group2 = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/grupos/welcomegp2.json'));

const bye_group2 = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/grupos/byegp2.json'));

const welkom = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/grupos/welkom.json'));

const { TelegraPh } = require("./fun√ß√µes/uploader");


//=====================================
const xfar = require('xfarr-api');
const path = require('path')
const fetch = require('node-fetch')
const os = require('os')
 const { TiktokDownloader } = require('./fun√ß√µes/tiktokdl') 
const moment = require('moment-timezone')
const { JSDOM } = require('jsdom')
const speed = require('performance-now')
const hx = require('./fun√ß√µes/hxz-api')
const { TiktokDownloaderr } = require('./fun√ß√µes/tiktokmikudl');
const stalker = require("xzons-api")
const hxz = require('./fun√ß√µes/hxz-api')
const { Aki } = require('aki-api')
const { lirikLagu } = require('./fun√ß√µes/letras.js')
const { insert, response } = require('./fun√ß√µes de cmd/fun√ß√µes/simi.js');


//=====================================
const welkom2 = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/usuarios/vacilo.json'));

const { color, bgcolor } = require('./fun√ß√µes/color')
const { convertSticker } = require("./fun√ß√µes de cmd/fun√ß√µes/swm.js");
const tamat = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/fun√ß√µes/tamat.json'))

const countMessage = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/grupos/countmsg.json'));

const { conselhob } = require('./fun√ß√µes de cmd/fun√ß√µes/conselhob.js');

const { palavras } = require('./fun√ß√µes de cmd/fun√ß√µes/conselhos.js');

const { mediafireDl } = require('./fun√ß√µes/mediafire')
//=====================================

const adeuscara = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/grupos/adeuscara.json'));

const { menu } = require("./fun√ß√µes de cmd/menu/menu.js")

const { menudono } = require("./fun√ß√µes de cmd/menu/menudono.js")

const { menulogos } = require('./fun√ß√µes de cmd/menu/menulogos.js');

const { infodono } = require('./fun√ß√µes de cmd/menu/infodono.js');

const { menuadm } = require("./fun√ß√µes de cmd/menu/menuadm.js")

//=====================================

const { EmojiAPI } = require("emoji-api")
const imgbbUploader = require('imgbb-uploader')
const { isLimit,  getLimit, giveLimit, addBalance, kurangBalance, getBalance, isGame, gameAdd, givegame, cekGLimit } = require('./fun√ß√µes/limit.js');
const emoji = new EmojiAPI()
const usedCommandRecently = new Set()
const { getLevelingXp, getLevelingLevel, getLevelingId, Telesticker, addLevelingXp, addLevelingLevel, addLevelingId, smsg, tanggal, getExtension, formatDate, getTime, isUrl, sleep, clockString, runtime, fetchJson, getBuffer, jsonformat, format, parseMention, getGroupAdmins,  getRandom } = require('./fun√ß√µes/myfunc')
const { aiovideodl } = require('./fun√ß√µes/scraper.js')
const cheerio = require ("cheerio");
const textpro = require('./fun√ß√µes/textpro')
const mimetype = require('mime-types')
const { segunPRONTOws } = require('./fun√ß√µes/segundo')
const { wikiSearch } = require('./fun√ß√µes/wiki.js');
const premium = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/usuarios/premium.json'));
const { upload, nit } = require('./fun√ß√µes de cmd/fun√ß√µes/tourl');

const { forwarding, imgnazista, imggay, imgcorno, imggostosa, imggostoso, imgfeio, imgvesgo, imgbebado, imggado, matarcmd, beijocmd, chutecmd, tapacmd } = require("./fun√ß√µes de cmd/nescessario.json")

//=====================================

const ms = require('ms')
 let { covid } = require('./fun√ß√µes/covid.js') 
const { yta,  ytv, searchResult  } = require('./fun√ß√µes/ytdl')
 
const forca = JSON.parse(fs.readFileSync('./fun√ß√µes/database/forca.json'))
const puppet = JSON.parse(fs.readFileSync('./fun√ß√µes/database/puppet_forca.json'))

//===================================== 
 
fake = "SUZANO-BOT ü©∏"


lolkey = global.lolhuman

keyapi = "key-2a-chefe"

//===================================== 
 
var prefix = global.prefix 

NomeDoBot = global.NomeDoBot

numerodn = global.numerodonoa   

NickDono = global.NickDono

banChats = global.banChats 

logo = global.log0

//===================================== 
 
let picaks = ['flamejante','flaming','flarun','flasmurf']
let picak = picaks[Math.floor(Math.random() * picaks.length)]

const meupirul = ['Hoje', 'Amanh√£', 'Nunca', 'dia', 'semana', 'm√™s', 'ano']
const meupirul2 = ['dias', 'semanas', 'meses', 'anos']

//========CONST=============\\

const nsfw = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/grupos/nsfw.json'));

const { destrava, destrava2 } = require('./fun√ß√µes de cmd/fun√ß√µes/destrava.js');

const samih = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/usuarios/simi.json'));

const samih2 = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/fun√ß√µes/simi.json'));

const akinator = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/fun√ß√µes/akinator.json'))

let limit = JSON.parse(fs.readFileSync('./jogos-rpg/user/limit.json'));

let leveling = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/fun√ß√µes/leveling.json'))

let autosticker = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/fun√ß√µes/autosticker.json'));

const autostick = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/fun√ß√µes/autostickpc.json'))

let _level = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/fun√ß√µes/level.json'))

const joguinhodavelhajs = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/usuarios/joguinhodavelha.json'));

const joguinhodavelhajs2 = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/usuarios/joguinhodavelha2.json'));

//========COME√áO ANTIS=============\\


const limitefll = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/usuarios/flood.json'));

const anticall = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/usuarios/anticall.json'));

const antifake = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antifake.json'))

const antilinkhard = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antilinkhard.json'))

const autofigu = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/grupos/autofigu.json'))

const antilinkgp = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antilinkgp.json'))

const antiporn = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antiporn.json'))

const antiimg = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antiimg.json'))

const antiflood = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/usuarios/antiflood.json'));

const antisticker = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antisticker.json'))

const antinotas = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antinotas.json'))

const antictt = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antictt.json'))

const anticatalogo = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/anticatalogo.json'))

const antidoc = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antidoc.json'))

const antiloc = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antiloc.json'))

const antipv = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/usuarios/antipv.json'))

const antivid = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antivideo.json'))

const antiaudio = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/antis/antiaudio.json'))

const palavra = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/grupos/palavras.json'))

const palavrao = JSON.parse(fs.readFileSync('./fun√ß√µes de cmd/grupos/palavrao.json'))



//========COME√áO=============\\



module.exports = pl = async (pl, m, messages, store) => {
try {
const info = messages ? messages[0]: messages[1]
if (!info.message) return 
if (info.key && info.key.remoteJid == 'status@broadcast') return

const baileys = require('@adiwajshing/baileys');

var type = baileys.getContentType(mek.message);


//==============(BODY)================\\
  var body = (type === 'conversation') ? info.message.conversation : (type == 'imageMessage') ? info.message.imageMessage.caption : (type == 'videoMessage') ? info.message.videoMessage.caption : (type == 'extendedTextMessage') ? info.message.extendedTextMessage.text : (type == 'buttonsResponseMessage') ? info.message.buttonsResponseMessage.selectedButtonId : (type == 'listResponseMessage') ? info.message.listResponseMessage.singleSelectReply.selectedRowId : (type == 'templateButtonReplyMessage') ? info.message.templateButtonReplyMessage.selectedId : (type === 'messageContextInfo') ? (info.message.buttonsResponseMessage?.selectedButtonId || info.message.listResponseMessage?.singleSelectReply.selectedRowId || info.text) : ''
  
const args = body.trim().split(/ +/).slice(1)

const q = args.join(' ')

const isCmd = body.startsWith(prefix)

const command = isCmd ? body.slice(1).trim().split(/ +/).shift().toLocaleLowerCase() : null

//================(BADY)================\\
 
bady = (type === 'conversation') ? info.message.conversation : (type == 'imageMessage') ? info.message.imageMessage.caption : (type == 'videoMessage') ? info.message.videoMessage.caption : (type == 'extendedTextMessage') ? info.message.extendedTextMessage.text : (info.message.listResponseMessage && info.message.listResponseMessage.singleSelectReply.selectedRowId) ? info.message.listResponseMessage.singleSelectReply.selectedRowId: ''

//=======================================\\

bidy =  bady.toLowerCase()
//===============(BUDY)==================\\

budy = (type === 'conversation') ? info.message.conversation : (type === 'extendedTextMessage') ? info.message.extendedTextMessage.text : ''

var budy2 = budy.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

//======================================\\

var pes = (type === 'conversation' && m.message.conversation) ? m.message.conversation : (type == 'imageMessage') && m.message.imageMessage.caption ? m.message.imageMessage.caption : (type == 'videoMessage') && m.message.videoMessage.caption ? m.message.videoMessage.caption : (type == 'extendedTextMessage') && m.message.extendedTextMessage.text ? m.message.extendedTextMessage.text : ''

//===========(ID DAS FIGUS)===========\\

const figura = Object.keys(m.message)[0] == "stickerMessage" ? m.message.stickerMessage.fileSha256.toString('base64') : ""

//=====================================\\

const listmsg = (from, title, desc, list) => { 
po = pl.prepareMessageFromContent(from, {"listMessage": {"title": title,"description": desc,"buttonText": "Escolha aqui","footerText": "Selecione","listType": 1,"sections": list}}, {})
return pl.relayWAMessage(po, {waitForAck: true})
}
listmes = (type == 'listResponseMessage') ? info.message.listResponseMessage.title : ''



//========FORMA√á√ïES/CONST)=============\\

const isOwner = [ ...global.numerodonoa].map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net').includes(m.sender)

const botNumber = pl.user.id.split(':')[0]+'@s.whatsapp.net'

const itsMe = m.sender == botNumber ? true : false

const text = args.join(" ")

const from = m.key.remoteJid
const isGroup = from.endsWith('@g.us') 
const quoted = m.quoted ? m.quoted : m
const mime = (quoted.msg || quoted).mimetype || ''


//========GRUPOS/CONST)=============\\

const groupMetadata = isGroup ? await pl.groupMetadata(from) : ''
const participants = isGroup ? await groupMetadata.participants : ''
const groupName = isGroup ? groupMetadata.subject : ''
const sender = isGroup ? m.key.participant : m.key.remoteJid
const pushname = m.pushName ? m.pushName : ''

const messagesC = pes.slice(0).trim().split(/ +/).shift().toLowerCase()

const arg = body.substring(body.indexOf(' ') + 1)


const argss = body.split(/ +/g)
const testat = body
const ants = body

const groupDesc = isGroup ? groupMetadata.desc : ''

const groupMembers = isGroup ? groupMetadata.participants : ''

const groupAdmins = isGroup ? getGroupAdmins(groupMembers) : ''

//=======================================\\



const numerodono = [ ...global.numerodonoa].map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net').includes(m.sender)
const dono = "557398095072@s.whatsapp.net"

//============(SORTEIO-CONST)============\\

const isSimi = isGroup ? samih.includes(from) : false

const isSimi2 = isGroup ? samih2.includes(from) : false


//=======(ADMS/DONO/ETC..CONST)========\\

const isNsfw =  isGroup ? nsfw.includes(from) : true

const isBot = m.key.fromMe ? true : false

const isPremium = premium.includes(sender)

const isBotAdmins = groupAdmins.includes(botNumber) || false

const isGroupAdmins = groupAdmins.includes(sender) || false 

const isBotGroupAdmins = groupAdmins.includes(botNumber) || false

//==============================

const welcm = isGroup ? wlcm.includes(from) : true
const GcRvk = isGroup ? gcrevoke.includes(from) : false
const isLevelingOn = isGroup ? leveling.includes(from) : false
const isAutoStick = autostick.includes(from)
const isAutoSticker = isGroup ? autosticker.includes(from) : false

const content = JSON.stringify(m.message)

//================COME√áO DOS ANTIS======================\\

//===========(ANTIS-PROTE√á√ïES)===========\\

const isAntifake = isGroup ? antifake.includes(from) : false

const isAntiCtt = isGroup ? antictt.includes(from) : false

const isAnticatalogo = isGroup ? anticatalogo.includes(from) : false

const isAntiFlood = isGroup ? antiflood.includes(from) : false	

const isAntiLinkHard = isGroup ? antilinkhard.includes(from) : false

//const isJoguin = isGroup ? joguinhodavelhajs.includes(sender) : false

const isAntilinkgp = isGroup ? antilinkgp.includes(from) : false

const isAntiPorn = isGroup ? antiporn.includes(from) : false

const isAntiAudio = isGroup ? antiaudio.includes(from) : false	
	
const isAntiImg = isGroup ? antiimg.includes(from) : false

const isAntiSticker = isGroup ? antisticker.includes(from) : false

const isAntiNotas = isGroup ? antinotas.includes(from) : false

const Antidoc = isGroup ? antidoc.includes(from) : false

const Antiloc = isGroup ? antiloc.includes(from) : false

const isAntiVid = isGroup ? antivid.includes(from) : false	

const isAutoReact = isGroup ? autoreact.includes(from) : false

const isWelkom2 = isGroup ? welkom2.includes(from) : true

const groupIdWelcomed2 = []	

for(let obj of welcome_group2) groupIdWelcomed2.push(obj.id)

const groupIdBye2 = []

for(let obj of bye_group2) groupIdBye2.push(obj.id)


const isWelcomed2 = (groupIdWelcomed2.indexOf(from) >= 0) ? true : false

const isByed2 = (groupIdBye2.indexOf(from) >= 0) ? true : false	
	

const isAntiPv = (antipv.indexOf('Ativado') >= 0) ? true : false	

const isAnticall = (anticall.indexOf('Ativado') >= 0) ? true : false

const isPalavrao = isGroup ? palavrao.includes(from) : false	

const isViewOnce = (type == 'viewOnceMessage')

const isWelkom = isGroup ? welkom.includes(from) : false

//=======================================\\
 

//=========(isQuoted/consts)=============\\
const isImage = type == 'imageMessage'
const isVideo = type == 'videoMessage'
const isAudio = type == 'audioMessage'
const isSticker = type == 'stickerMessage'
const isContact = type == 'contactMessage'
const isLocation = type == 'locationMessage'
const isProduct = type == 'productMessage'
const isMedia = (type === 'imageMessage' || type === 'videoMessage' || type === 'audioMessage')
typeMessage = body.substr(0, 50).replace(/\n/g, '')
if (isImage) typeMessage = "Image"
else if (isVideo) typeMessage = "Video"
else if (isAudio) typeMessage = "Audio"
else if (isSticker) typeMessage = "Sticker"
else if (isContact) typeMessage = "Contact"
else if (isLocation) typeMessage = "Location"
else if (isProduct) typeMessage = "Product"

const isQuotedMsg = type === 'extendedTextMessage' && content.includes('textMessage')

const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')

const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')

const isQuotedDocument = type === 'extendedTextMessage' && content.includes('documentMessage')

const isQuotedAudio = type === 'extendedTextMessage' && content.includes('audioMessage')

const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')

const isQuotedContact = type === 'extendedTextMessage' && content.includes('contactMessage')

const isQuotedLocation = type === 'extendedTextMessage' && content.includes('locationMessage')

const isQuotedProduct = type === 'extendedTextMessage' && content.includes('productMessage')
             
//==========================================\\

selectedButton = (type == 'buttonsResponseMessage') ? m.message.buttonsResponseMessage.selectedButtonId : ''

//==========================================\\


  const argsButton = selectedButton.trim().split(/ +/)

//==========================================\\

const getFileBuffer = async (mediakey, MediaType) => {
  
const stream = await downloadContentFromMessage(mediakey, MediaType)

let buffer = Buffer.from([])
for await(const chunk of stream) {
buffer = Buffer.concat([buffer, chunk])
}
return buffer
}

 try {
ppimg = await pl.profilePictureUrl(sender)
 } catch {
ppimg = 'https://i0.wp.com/www.gambarunik.id/wp-content/uploads/2019/06/Top-Gambar-Foto-Profil-Kosong-Lucu-Tergokil-.jpg'
 }
const userppbuff = await getBuffer(ppimg) 


const sendSticker = (from, filename, m) => {
pl.sendMessage(from, {sticker: filename}, {quoted: m})
}

const sendImage = (ytb) => {
pl.sendMessage(from, {image: ytb}, {quoted:m})
}


const sendMess = (hehe, ytb) => {
pl.sendMessage(hehe, {text: ytb})
}

	const pickRandom = (arr) => {
			return arr[Math.floor(Math.random() * arr.length)]
		}

const mentions = (teks, memberr, id) => {
(id == null || id == undefined || id == false) ? pl.sendMessage(from, {text: teks.trim(), mentions: memberr}) : pl.sendMessage(from, {text: teks.trim(), mentions: memberr})
}
	
const costum = (pesan, tipe, target, target2) => {
pl.sendMessage(from, pesan, tipe, {quoted: {key: {fromMe: false, participant: `${target}`, ...(from ? {remoteJid: from}: {})}, message: {conversation: `${target2}` }}})
}

const sendlistA = async (id, txt1, txt2, title1, btext, but) => {

const sections = but

const listMessage = {
text: txt1,
footer: txt2,
title: title1,
buttonText: btext,
sections
}
pl.sendMessage(id, listMessage)  
}


//=========HORAS=============

function kyun(seconds){
function pad(s){
return (s < 10 ? '0' : '') + s;
}
var hours = Math.floor(seconds / (60*60));
var minutes = Math.floor(seconds % (60*60) / 60);
var seconds = Math.floor(seconds % 60);
return `${pad(hours)} HORAS ${pad(minutes)} MINUTOS ${pad(seconds)} SEGUNDOS`
}



const time2 = moment().tz('America/Sao_Paulo').format('HH:mm:ss')
if(time2 > "00:00:00"){
var tempo = 'BOA MADRUGADA' 
} 
if(time2 > "05:30:00"){
var tempo = 'BOM DIA' 
}
if(time2 > "12:00:00"){
var tempo = 'BOA TARDE' 
}
if(time2 > "19:00:00"){
var tempo = 'BOA NOITE' 
}



//========REPLY========================

var selo = {
    key: {
fromMe: false,
"participant": "0@s.whatsapp.net",
"remoteJid": "120363022697760691@g.us"
    },
    "message": {
orderMessage: {
itemCount: -9999999,
status: 200,
jpegThumbnail: fs.readFileSync('./m√≠dia-ft-vd/fotos/manu.jpg'),
surface: 200,
message: `${NomeDoBot}\nComando: ${prefix + command}`,
orderTitle: 'samods',
sellerJid: '0@s.whatsapp.net'
}
    },
    contextInfo: {
"forwardingScore": 999,
"isForwarded": true
    },
    sendEphemeral: true
}


const reply = (texto) => {
pl.sendMessage(from, { text: texto }, {quoted:m}).catch(e => {
console.log(e)
})
}

//=====================================
     
pl.createMessage = async (jidnya, kontennya, optionnya) => {
return await generateWAMessage(jidnya, kontennya, {...optionnya,userJid: pl.authState.creds.me.id,upload: pl.waUploadToServer})
}

//=====================================


function randomNomor(angka){
return Math.floor(Math.random() * angka) + 1
}

//=============DATA=============

const date = moment.tz('America/Sao_Paulo').format('DD/MM/YY');


const time = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

const hora = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

const Data = moment.tz('America/Sao_Paulo').format('DD/MM/YY');

//=====================================

//=====================================
// ‚ùóùô≤ùôæùôºùô∞ùôΩùô≥ùôæ ùôΩùôæ ùôøùöÖ‚ùó
if (!isGroup && isCmd) console.log(
color('„Ää‚ùóCO–úANDO PRIVADO‚ùó„Äã','white'),'\n',
color('‚Ä£ NŒôCK :','red'),color(pushname,'cyan'),'\n',
color('‚Ä£ N√öMERO :','red'),color(sender.split("@")[0],'blue'),'\n',
color('‚Ä£ C–úD :','red'),color(command,'cyan'),'\n',
color('‚Ä£ HORA :','red'),color(hora,'cyan'),'\n',
color('‚Ä£ DA–¢A :','red'),color(Data,'cyan'),'\n')

// ‚ùóùôºùô¥ùôΩùöÇùô∞ùô∂ùô¥ùôº ùôΩùôæ ùôøùöÖ‚ùó
if (!isCmd && !isGroup && !info.key.fromMe) console.log(
color('„Ää‚ùóMENSAGEM PRIVADO‚ùó„Äã','white'),'\n',
color('‚Ä£ N√öMERO :','red'),color(sender.split("@")[0],'blue'),'\n',
color('‚Ä£ NICK :','red'),color(pushname,'cyan'),'\n',
color('‚Ä£ HORA :','red'),color(hora,'cyan'),'\n',
color('‚Ä£ DATA :','red'),color(Data,'cyan'),'\n')

// ‚ùóùô≤ùôæùôºùô∞ùôΩùô≥ùôæ ùô¥ùôº ùô∂ùöÅùöÑùôøùôæ‚ùó
if (isCmd && isGroup) console.log(
color('„Ää‚ùóCO–úANDO NO GRUPO‚ùó„Äã','white'),'\n',
color('‚Ä£ GRUPO :','blue'),color(groupName,'yellow'),'\n',
color('‚Ä£ N√öMERO :','blue'),color(sender.split("@")[0],'red'),'\n',
color('‚Ä£ NICK :','blue'),color(pushname,'yellow'),'\n',
color('‚Ä£ CMD :','blue'),color(command,'yellow'),'\n',
color('‚Ä£ HORA :','blue'),color(hora,'yellow'),'\n',
color('‚Ä£ DATA :','blue'),color(Data,'yellow'),'\n')

// ‚ùóùôºùô¥ùôΩùöÇùô∞ùô∂ùô¥ùôº ùô¥ùôº ùô∂ùöÅùöÑùôøùôæ‚ùó
if (!isCmd && isGroup && !info.key.fromMe) console.log(
color('„Ää‚ùóMENSAGEM NO GRUPO ‚ùó„Äã','white'),'\n',
color('‚Ä£ GRUPO :','blue'),color(groupName,'cyan'),'\n',
color('‚Ä£ N√öMERO :','blue'),color(sender.split("@")[0],'red'),'\n',
color('‚Ä£ NICK :','blue'),color(pushname,'cyan'),'\n',
color('‚Ä£ HORA :','blue'),color(hora,'cyan'),'\n',
color('‚Ä£ DATA :','blue'),color(Data,'cyan'),'\n')

		


//===================================== 



//=====================================


//===========(enviar.espere)=============\\

const { mensagens } = require('./fun√ß√µes de cmd/fun√ß√µes/aleatoria.js');

const { sortear } = require('./fun√ß√µes de cmd/fun√ß√µes/aleatoria.js');

var enviarmen = mensagens[Math.floor(Math.random() * mensagens.length)] 
//========================================\\


//=====================================

enviar = {
espere: `${enviarmen}`,
successo: 'Ô∏è‚ù¨ ‚úî ‚ù≠ Sucesso üñ§',
levelon: '‚ù¨ ‚úî ‚ù≠ *leveling* *ativado*',
leveloff: '‚ù¨ X ‚ù≠  *leveling* *desativado*',
levelnoton: '‚ù¨ X ‚ù≠ *leveling n√£o ativado*',
levelnol: '*error* 0 ¬∞-¬∞',
error: {
stick: '*falhou, tente novamente ^_^*',
Iv: 'Link invalido ‚òπÔ∏è'
},
msg: {
grupo: '[‚ùó] Este comando s√≥ pode ser usado em grupos! ‚ùå',
premium: '[‚ùó] ESTE PEDIDO √â SO PARA *USU√ÅRIOS PREMIUMS*',
autoriza√ß√£o: "Somente o desenvolvedor ou admistradores podem executar esse comando!",
mod: `[‚ùó] ESTE PEDIDO √â ESPEC√çFICO PARA USUARIO MOD ${global.NickDono}*`,
banido: '‚ùå Voc√™ foi banido de utilizar os comandos, entre em contato com o propriet√°rio pra saber o porque ‚ùå' ,
donosmt: '[‚ùó] Este √© um recurso especial para o propriet√°rio ‚ùå',
donosmt2: '[‚ùó] Este √© um recurso especial para o propriet√°rio ‚ùå',
adm: '[‚ùó] Este comando s√≥ pode ser usado por administradores de grupo! ‚ùå',
Badmin: ' [‚ùó] Este comando s√≥ pode ser usado quando o bot se torna administrador! ‚ùå',
}
}

resposta = {
espere: "Aguarde...enviando ",
dono: "Esse comando s√≥ pode ser usado pelo desenvolvedor!!! ",
grupo: "Esse comando s√≥ pode ser usado em grupos ",
privado: "Esse comando s√≥ pode ser usado no privado ",
adm: "Esse comando s√≥ pode ser usado por administradores do grupo",
botadm: "Este comando s√≥ pode ser usado quando o bot se torna administrador ",
erro: "Erro, tente novamente mais tarde "
}
//=====================================

const sendBtext = async (id, text1, desc1, but = [], vr) => {
buttonMessage = {
text: text1,
footer: desc1,
buttons: but,
headerType: 1
}
pl.sendMessage(id, buttonMessage, {quoted: vr})
}

//=====================================
    
//=====================================



const enviarimg = (imageDir, caption) => {
pl.sendMessage(from, {
image: fs.readFileSync(imageDir),
caption: caption
})
}

// ENVIAR BOT√ÉO COM IMAGEM
const sendBimg = async (id, img1, text1, desc1, but = [], vr) => {
buttonMessage = {
image: {url: img1},
caption: text1,
footer: desc1,
buttons: but,
headerType: 4
}
pl.sendMessage(id, buttonMessage, {quoted: vr})
}
   

//========AUTOFIGU-GP/AUTOFIGU-PV=============

const enviarfigu = async (figu, tag) => {
bla = fs.readFileSync(figu)
pl.sendMessage(from, {sticker: bla}, {quoted: info})
}

const enviarfiguUrl = async (link) => {
ranp = getRandom('.gif')
rano = getRandom('.webp')
ini_buffer = `${link}`
exec(`wget ${ini_buffer} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 320:320 ${rano}`, (err) => {
fs.unlinkSync(ranp)
buff = fs.readFileSync(rano)
pl.sendMessage(from, {sticker: buff}, {quoted: info}).catch(e => {
})
fs.unlinkSync(rano)
})
}

if(isAutoSticker &&  !m.key.fromMe && isGroup) {
async function autofiguf() {
await setTimeout(async() => {    
if(budy.includes(`${prefix}sticker`) || budy.includes(`${prefix}s`) || budy.includes(`${prefix}stk`) || budy.includes(`${prefix}st`) || budy.includes(`${prefix}fsticker`) || budy.includes(`${prefix}f`) || budy.includes(`${prefix}fstiker`)) return
if(type === "videoMessage") {
if ((isMedia && info.message.videoMessage.seconds < 40)){  
rane = getRandom('.'+await getExtension(info.message.videoMessage.mimetype))
buffimg = await getFileBuffer(info.message.videoMessage, 'video')
fs.writeFileSync(rane, buffimg)
const media = rane
rano = getRandom('.webp')
await ffmpeg(`./${media}`)
.inputFormat(media.split('.')[1])
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
exec(`webpmux -set exif ${addMetadata('bot', 'manu')} ${rano} -o ${rano}`, async (error) => {
fs.unlinkSync(media)
tipe = media.endsWith('.mp4') ? 'video' : 'gif'
reply(`Falha na convers√£o de ${tipe} para sticker`)
})
})
exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 200:200 ${rano}`, (err) => {
fs.unlinkSync(media)
buffer = fs.readFileSync(rano)
pl.sendMessage(from, {sticker: buffer}, {quoted: info})
fs.unlinkSync(rano)
})
} 
}

if(type === "imageMessage") {
rane = getRandom('.'+await getExtension(info.message.imageMessage.mimetype))
buffimg = await getFileBuffer(info.message.imageMessage, 'image')
fs.writeFileSync(rane, buffimg)
const media = rane
rano = getRandom('.webp')
exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${rano}`, (err) => {
fs.unlinkSync(media)
buffer = fs.readFileSync(rano)
pl.sendMessage(from, {sticker: buffer}, {quoted: info})
fs.unlinkSync(rano)
})  
}
}, 1000)
}
autofiguf().catch(e => {
console.log(e)
})
}

/*

if (isGroup && !m.key.fromMe && type == 'viewOnceMessage') {
let teks = `„Äå *ANTI VIEWONCE ATIVADO * „Äç
    
    ü§† *NOME* : ${pushname}
    üëæ *USU√ÅRIO* : @${sender.split("@")[0]}
    ‚è∞ *Rel√≥gio* : ${moment.tz('America/Sao_Paulo').format('HH:mm:ss')}
    
    üí´ *MENSAGEM DENTRO* : ${type}`
reply(teks)
await sleep(500)
m.copyNForward(from, true, {
readViewOnce: true
}, {
quoted: mek
}).catch(_ => reply(`ERROOO`))
}

*/
//=====================================

/*
if (isAutoStick && isGroup) {
     if(type == "imageMessage") {
await pl.sendImageAsSticker(from, m,    {packname: global.packname, author: global.author })
console.log(`DETECTADO AUTOSTICKER `)
} else if(type == "videoMessage") {
await pl.sendVideoAsSticker(from, m,  {packname: global.packname, author: global.author })
}
}
*/

//=====================================

if(isAutoReact && isGroup && isCmd) {
if(!isAutoReact) return 
emojis = ["üòÄ", "üòÉ", "üòÅ", "üòÜ", "üòÇ", "ü§£", "üò≠", "üòâ", "üòò", "üòó", "ü•∞", "üòç", "ü§©", "ü•≥", "üôÉ", "üôÇ", "ü•≤", "üòã", "üòõ", "üòú", "üòù", "üòú", "üòá", "üòä", "‚ò∫Ô∏è", "üòè", "üòå", "üòî", "üòë", "üòê", "üò∂", "ü§î", "ü§´", "ü§≠", "ü•±", "ü§ó", "ü§®", "üßê", "üòí", "üôÑ", "üò§", "üò†", "ü§¨", "ü•∫", "üò•", "üòü", "‚òπÔ∏è", "üò¶", "üòß", "üò∞", "üò®", "üòï", "üòØ", "üò≤", "üò≥", "ü§Ø", "üò¨", "üòì", "üòì", "üòû", "üòñ", "ü•¥", "üòé", "ü§ì", "üòé", "ü•µ", "ü•∂", "üåû", "ü§¢", "ü§Æ", "ü§•", "ü§°", "üòà", "ü•µ", "üëΩ", "üò∑", "üí¶", "üë∫", "üëπ", "üí®", "üò∏", "üòπ", "‚ù§Ô∏è", "ü´Ä", "üëÅÔ∏è", "‚ò†Ô∏è", "üíÄ", "üëÄ", "üòª", "üíã", "ü´Ç", "üëÑ", "üëÖ", "üíÖ", "üôè", "ü§≥", "‚úçÔ∏è", "üôÖ", "üåÄ", "‚òÉÔ∏è", "üî•", "‚ö°", "üåà", "üíß", "üôà", "üçë", "üçí", "üçì", "üçå", "üå∂Ô∏è", "üçÜ", "üç¥", "üç∑", "üç¥", "üçΩÔ∏è", "üõ¢Ô∏è", "üö®", "üé§", "üé≠", "üìΩÔ∏è", "üé∞", "‚òéÔ∏è", "üìû", "üëë", "üíé", "üíç", "üíâ", "üóëÔ∏è", "üó°Ô∏è", "‚öîÔ∏è", "üö¨", "üí£", "‚ÅâÔ∏è", "‚úÖ", "üëÅÔ∏è‚Äçüó®Ô∏è", "‚ô•Ô∏è", "üß°", "üíõ", "üíö", "üíô", "üíú", "ü§é", "üñ§", "ü§ç", "üáßüá∑", "üè≥Ô∏è‚Äçüåà", "üá≤üáΩ", "üá™üá∏", "üá≤üáø", "üá¶üá¥", "üá∫üá≤","ü§î","ü§´","üòè","üçÜ","üë∫","üôä"]
reassao = emojis[Math.floor(Math.random() * emojis.length)]
sendMsg = await pl.sendMessage(from, {react: {text: reassao, key: m.key}})
}

if(isAutoReact && isGroup && !isCmd) {
if(!isAutoReact) return 
emojis = ["üòÄ", "üòÉ", "üòÅ", "üòÜ", "üòÇ", "ü§£", "üò≠", "üòâ", "üòò", "üòó", "ü•∞", "üòç", "ü§©", "ü•≥", "üôÉ", "üôÇ", "ü•≤", "üòã", "üòõ", "üòú", "üòù", "üòú", "üòá", "üòä", "‚ò∫Ô∏è", "üòè", "üòå", "üòî", "üòë", "üòê", "üò∂", "ü§î", "ü§´", "ü§≠", "ü•±", "ü§ó", "ü§®", "üßê", "üòí", "üôÑ", "üò§", "üò†", "ü§¨", "ü•∫", "üò•", "üòü", "‚òπÔ∏è", "üò¶", "üòß", "üò∞", "üò®", "üòï", "üòØ", "üò≤", "üò≥", "ü§Ø", "üò¨", "üòì", "üòì", "üòû", "üòñ", "ü•¥", "üòé", "ü§ì", "üòé", "ü•µ", "ü•∂", "üåû", "ü§¢", "ü§Æ", "ü§•", "ü§°", "üòà", "ü•µ", "üëΩ", "üò∑", "üí¶", "üë∫", "üëπ", "üí®", "üò∏", "üòπ", "‚ù§Ô∏è", "ü´Ä", "üëÅÔ∏è", "‚ò†Ô∏è", "üíÄ", "üëÄ", "üòª", "üíã", "ü´Ç", "üëÑ", "üëÖ", "üíÖ", "üôè", "ü§≥", "‚úçÔ∏è", "üôÖ", "üåÄ", "‚òÉÔ∏è", "üî•", "‚ö°", "üåà", "üíß", "üôà", "üçë", "üçí", "üçì", "üçå", "üå∂Ô∏è", "üçÜ", "üç¥", "üç∑", "üç¥", "üçΩÔ∏è", "üõ¢Ô∏è", "üö®", "üé§", "üé≠", "üìΩÔ∏è", "üé∞", "‚òéÔ∏è", "üìû", "üëë", "üíé", "üíç", "üíâ", "üóëÔ∏è", "üó°Ô∏è", "‚öîÔ∏è", "üö¨", "üí£", "‚ÅâÔ∏è", "‚úÖ", "üëÅÔ∏è‚Äçüó®Ô∏è", "‚ô•Ô∏è", "üß°", "üíõ", "üíö", "üíô", "üíú", "ü§é", "üñ§", "ü§ç", "üáßüá∑", "üè≥Ô∏è‚Äçüåà", "üá≤üáΩ", "üá™üá∏", "üá≤üáø", "üá¶üá¥", "üá∫üá≤","ü§î","ü§´","üòè","üçÜ","üë∫","üôä"]
reassao = emojis[Math.floor(Math.random() * emojis.length)]
sendMsg = await pl.sendMessage(from, {react: {text: reassao, key: m.key}})
}


//===============(simih)=============\\
const simih = async (text) => {
	try {
		const sami = await fetch(`https://api.brizaloka-api.tk/ia/simsimi?apikey=brizaloka&text=${text}`, {method: 'GET'})
		const res = await sami.json()
		return res.resultado.resposta
	} catch {
		return 'Simi n√£o sabe, pfvr explique ??'
	}
}


async function AntilinkHardF() {
if(isUrl(budy2) && isAntiLinkHard && isGroupAdmins && isBotGroupAdmins && !info.key.fromMe) {
if(command == "tiktok" && command == "facebook" && command == "instagram" && command == "tiktok" && command == "twitter" && command == "ytmp3" && command == "ytmp4" && command == "play") return
linkgpp = await pl.groupInviteCode(from)
if(budy2.match(`${linkgpp}`)) return
if(!isUrl(budy2)) return 
if(type === "buttonsResponseMessage") return
if(type === "listResponseMessage") return
if(budy2.includes(`${linkgpp}`)) return 
reply('*Link detectado, por√©m usu√°rio √© admin*')
}

if(isUrl(budy2) && isAntiLinkHard && !isGroupAdmins && isBotGroupAdmins && !info.key.fromMe) {
if(command == "tiktok" && command == "facebook" && command == "instagram" && command == "tiktok" && command == "twitter" && command == "ytmp3" && command == "ytmp4" && command == "play") return  
linkgpp = await pl.groupInviteCode(from)
if(budy2.match(`${linkgpp}`)) return reply('Link do nosso grupo, n√£o irei remover.. ')  
if(!isUrl(budy2)) return 
if(type === "buttonsResponseMessage") return
if(type === "listResponseMessage") return
reply('*Link detectado, punindo usu√°rio...*')
if(!JSON.stringify(groupMembers).includes(sender)) return
pl.groupParticipantsUpdate(from, [sender], 'remove')
}
} 
AntilinkHardF()
//joguinhodavelha()

if(isUrl(body) && isAntilinkgp && isGroup && isBotGroupAdmins) {
if(!isAntilinkgp) return
if(!isUrl(body)) return 
if(isGroupAdmins) return reply("Voc√™ √© adm, n√£o removerei voc√™..") 
if(budy2.includes("chat.whatsapp.com/")){
if(!budy2.includes("chat.whatsapp.com/")) return
if(isBot) return 
linkgpp = await pl.groupInviteCode(from)
if(budy.match(`${linkgpp}`)) return reply('Link do nosso grupo, n√£o irei remover.. ')  
reply('*Link de grupo detectado, punindo usu√°rio...*')
if(!JSON.stringify(groupMembers).includes(sender)) return
pl.groupParticipantsUpdate(from, [sender], 'remove')
}
}




if(isGroup && isBotGroupAdmins && !isGroupAdmins && !isOwner && !info.key.fromMe) {
if(info.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length == groupMembers.length || info.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length == groupMembers.length - 1) { 
reply("MEMBRO COM MENSAGEM DE MARCA√á√ÉO DE TODOS DO GRUPO, POR CONTA DISSO VOU REMOVER DO GRUPO, QUALQUER COISA V√Å NO PV DO ADMINISTRADOR...")
pl.groupParticipantsUpdate(from, [sender], "remove")
}
}

/*
//========(ANTI-PV-QUE-BLOQUEIA)======\\
if(isAntiPv && !isGroup && !isOwner  && !m.key.fromMe && !isPremium){ 
reply(`_N√£o √© permitido conversar no pv do bot!\npor isso vc ser√° bloqueado!\nqualquer coisa contate ao desenvolvedor_`)
setTimeout(async () => {
pl.updateBlockStatus(sender, 'block')
}, 1000)
return
}*/
//======================================\\


// ANTI_LIGAR \\

if(!isGroup && isAnticall) {
pl.ws.on('CB:call', async (B) => {
if (B.content[0].tag == 'offer') {
pl.sendMessage(B.content[0].attrs['call-creator'], { text: "N√£o pode ligar para o bot, voc√™ ser√° bloqueado..." }).then(() => { 
delay(4000)
pl.updateBlockStatus(B.content[0].attrs['call-creator'], "block") })
}
})
}


//=========(ANTIPV-QUE-S√ì-FALA)==========\\
/*
if(!isGroup && !isPremium && !isOwner && !m.key.fromMe && banChats === true) return 
const atibot = m.isBaileys
if (atibot === true) return 
*/

//======================================\\
 
if(fs.existsSync(`./func/limitecaracteres/limite-c_${from}.json`)) {
var limitecaracteres_on = JSON.parse(fs.readFileSync(`./func/limitecaracteres/limite-c_${from}.json`))
var limitefl = limitecaracteres_on.limite
} else {
var limitefl = limitefll.limitefl
}



      const allForcaId = []
for(let obj of forca) allForcaId.push(obj.id)
const isPlayForca = allForcaId.indexOf(sender) >= 0 ? true : false

async function randompalavra() {
    return new Promise(async (resolve, reject) => {
fetch('https://www.palabrasaleatorias.com/palavras-aleatorias.php?fs=1&fs2=0&Submit=Nova+palavra',).then(async function (res, err) {
if(err) reject(err)    
var $ = cheerio.load(await res.text())
resolve($('body > center > center > table:nth-child(4) > tbody > tr > td > div')[0].children[0].data)
})
    }) 
}


//===================================== 

const enviarfiguimg = async (jid, path, quoted, options = {}) => {
let buff = Buffer.isBuffer(path) ? path: /^data:.*?\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64'): /^https?:\/\//.test(path) ? await (await getBuffer(path)): fs.existsSync(path) ? fs.readFileSync(path): Buffer.alloc(0)
let buffer
if (options && (options.packname || options.author)) {
 buffer = await writeExifImg(buff, options)
} else {
 buffer = await imageToWebp(buff)
}
await pl.sendMessage(jid, {
 sticker: {
url: buffer
 }, ...options
}, {
 quoted
})
return buffer
 }

//===================================== 

 const enviarfiguvid = async (jid, path, quoted, options = {}) => {
let buff = Buffer.isBuffer(path) ? path: /^data:.*?\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64'): /^https?:\/\//.test(path) ? await (await getBuffer(path)): fs.existsSync(path) ? fs.readFileSync(path): Buffer.alloc(0)
let buffer
if (options && (options.packname || options.author)) {
 buffer = await writeExifVid(buff, options)
} else {
 buffer = await videoToWebp(buff)
}

await pl.sendMessage(jid, {
 sticker: {
url: buffer
 }, ...options
}, {
 quoted
})
return buffer
 }    
 

//=======================\\

const mencionar = ( foto, texto, membro, ids ) => {
( ids == null || ids == undefined || ids == false ) ? pl.sendMessage(from, { image: foto, caption: texto.trim(), contextInfo: { "mentionedJid": membro } }) : pl.sendMessage(from, { image: foto, caption: texto.trim(), contextInfo: { "mentionedJid": membro } })
}

//========================\\

//-_-_-_-_--_-_-_-_-_--_-JSON-FUN√á√ïES-_-_-_-_-_-_-_-_-_-_-_-_\\
const { addVotoDuelo, delVotoDuelo } = require('./funcoes/votoduelo.js')

//-_-_-_-_--_-_-_-_-_--_--_-_-_-_-_-_-_-_-_-_-_-_\\

const votacao = JSON.parse(fs.readFileSync('./dados/votacao/votacao.json'))

const votacaoduelo = JSON.parse(fs.readFileSync('./dados/duelo/votacaoduelo.json'))
//-_-_-_-_--_-_-_-_-_--_--_-_-_-_-_-_-_-_-_-_-_-_\\

//============(FUN√á√ïES)============\\

const isVoto = isGroup ? votacao.includes(from) : false

const isVotoDuelo = isGroup ? votacaoduelo.includes(from) : false

//-_-_-_-_--_-_-_-_-_--_--_-_-_-_-_-_-_-_-_-_-_-_\\

/** VOTA√á√ÉO ESTILO DUELO : VS **/

if( isGroup ) {

if (budy.toLowerCase() === 'um'){

let voto = JSON.parse(fs.readFileSync(`./dados/duelo/P_votos/${from}.json`))
let _votos = JSON.parse(fs.readFileSync(`./dados/duelo/votos/${from}.json`))
let filtro = voto.map(v => v.participante)
let id_voto = sender ? sender : '0@s.whatsapp.net'
if(filtro.includes(id_voto)) {
return mentions('Ol√° '+'@' + sender.split('@')[0] + '\n~ N√£o √© poss√≠vel votar duas vezes.', filtro, true)
} else {
voto.push({
participante: id_voto,
votacao: '1'
})
fs.writeFileSync(`./dados/duelo/P_votos/${from}.json`,JSON.stringify(voto))
let _p = []
let _voto = `VOTA√á√ÉO...\n\nParticipante 1: @${_votos[0].votos.split('@')[0]}\nParticipante 2: @${_votos[0].votos2.split('@')[0]}\nMotivo da vota√ß√£o: ${_votos[0].razao}\nTotal de votos: ${voto.length}.\nDura√ß√£o: ${_votos[0].duracao} minuto.`
for(let i = 0; i < voto.length; i++) {
_voto +=  `\n\n========\nMembro: @${voto[i].participante.split('@')[0]}\nVotou em: ${voto[i].votacao}\n========`
_p.push(voto[i].participante)
}
_p.push(_votos[0].votos, _votos[0].votos2)
mentions(_voto,_p,true)
}
} else if (budy.toLowerCase() === 'dois'){
const voto = JSON.parse(fs.readFileSync(`./dados/duelo/P_votos/${from}.json`))
let _votos = JSON.parse(fs.readFileSync(`./dados/duelo/votos/${from}.json`))
let filtro = voto.map(v => v.participante)
let id_voto = sender ? sender : '0@s.whatsapp.net'
if(filtro.includes(id_voto)) {
return mentions('Ol√° '+'@' + sender.split('@')[0] + '\n~ N√£o √© possivel votar duas vezes.', filtro, true)
} else {
voto.push({
participante: id_voto,
votacao: '2'
})
fs.writeFileSync(`./dados/duelo/P_votos/${from}.json`,JSON.stringify(voto))
let _p = []
let _voto = `VOTA√á√ÉO...\n\nParticipante 1: @${_votos[0].votos.split('@')[0]}\nParticipante 2: @${_votos[0].votos2.split('@')[0]}\nMotivo da vota√ß√£o: ${_votos[0].razao}\nTotal de votos: ${voto.length}.\nDura√ß√£o: ${_votos[0].duracao} minuto.`
for(let i = 0; i < voto.length; i++) {
_voto +=  `\n\n========\nMembro: @${voto[i].participante.split('@')[0]}\nVotou em: ${voto[i].votacao}\n========\n`
_p.push(voto[i].participante)
}
_p.push(_votos[0].votos, _votos[0].votos2)
mentions(_voto,_p,true)
}
}
}	


//======================================\\

//========(CONTADOR-DE-MENSAGENS)========\\

const groupIdscount = []
const numbersIds = []
for(let obj of countMessage) {
groupIdscount.push(obj.groupId)
}
if(isGroup && groupIdscount.indexOf(from) >= 0) {
var ind = groupIdscount.indexOf(from)
for(let obj of countMessage[ind].numbers) {numbersIds.push(obj.id)}
if(numbersIds.indexOf(sender) >=0) {
var indnum = numbersIds.indexOf(sender)
countMessage[ind].numbers[indnum].messages += 1
countMessage[ind].numbers[indnum].cmd_messages += isCmd ? 1 : 0
fs.writeFileSync('./fun√ß√µes de cmd/grupos/countmsg.json', JSON.stringify(countMessage, null, 2)+ '\n')
} else {
const messages = 1
const cmd_messages = isCmd ? 1 : 0
countMessage[ind].numbers.push({
id: sender,
messages: messages,
cmd_messages: cmd_messages
})
fs.writeFileSync('./fun√ß√µes de cmd/grupos/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n')
}
} else if(isGroup) {
countMessage.push({
groupId: from,
numbers: [{
id: sender,
messages: 2,
cmd_messages: isCmd ? 1 : 0
}]
})
fs.writeFileSync('./fun√ß√µes de cmd/grupos/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n')
}


//======================================\\

//===============(AUTO-BAN)=============\\
const dbids = []
for(i=0;i<adeuscara.length;++i) {
dbids.push(adeuscara[i].groupId)
}
const isAdeusCara = (isGroup && dbids.indexOf(from) >= 0) ? true : false

//======================================\\


//=====================================   

this.suit = this.suit ? this.suit : {}
let roof = Object.values(this.suit).find(roof => roof.id && roof.status && [roof.p, roof.p2].includes(m.sender))
if (roof) {
let win = ''
let tie = false
if (sender == roof.p2 && /^(acc(ept)?|aceitar|Aceitar|Ok?|aceita|A√ß√£o|Posterior|ga(k.)?bisa|y)/i.test(m.text) && m.isGroup && roof.status == 'wait') {
if (/^(Menos|A√ß√£o|rejeitar|n|ga(k.)?bisa)/i.test(m.text)) {
pl.sendTextWithMentions(from, `@${roof.p2.split`@`[0]} terno de lixo, terno cancelado`, m)
delete this.suit[roof.id]
return !0
}
roof.status = 'play'
roof.asal = from
clearTimeout(roof.waktu)
//delete roof[roof.id].waktu
pl.sendText(from, `O jogo foi enviado para conversar.

@${roof.p.split`@`[0]} e 
@${roof.p2.split`@`[0]}

Selecione o jogo em cada bate-papo"
clique https://wa.me/${botNumber.split`@`[0]}`, m, { mentions: [roof.p, roof.p2] })
if (!roof.pilih) pl.sendText(roof.p, `Por favor, selecione \n\nPedraüóø\nPapelüìÑ\nTesoura‚úÇÔ∏è`, m)
if (!roof.pilih2) pl.sendText(roof.p2, `Por favor, selecione \n\nPedraüóø\nPapelüìÑ\Tesoura‚úÇÔ∏è`, m)
roof.waktu_milih = setTimeout(() => {
if (!roof.pilih && !roof.pilih2) pl.sendText(from, `Ambos os jogadores n√£o t√™m inten√ß√£o de jogar,\njogo cancelado`)
else if (!roof.pilih || !roof.pilih2) {
win = !roof.pilih ? roof.p2 : roof.p
pl.sendTextWithMentions(from, `@${(roof.pilih ? roof.p2 : roof.p).split`@`[0]} n√£o escolher um jogo, o jogo terminou`, m)
}
delete this.suit[roof.id]
return !0
}, roof.timeout)
}
let jwb = m.sender == roof.p
let jwb2 = m.sender == roof.p2
let g = /tesoura/i
let b = /pedra/i
let k = /papel/i
let reg = /^(tesoura|pedra|papel)/i
if (jwb && reg.test(m.text) && !roof.pilih && !m.isGroup) {
roof.pilih = reg.exec(m.text.toLowerCase())[0]
roof.text = m.text
reply(`Voc√™ escolheu ${m.text} ${!roof.pilih2 ? `\n\nEsperando que o oponente escolha` : ''}`)
if (!roof.pilih2) pl.sendText(roof.p2, '_O oponente j√° escolheu_\nAgora √© sua vez.', 0)
}
if (jwb2 && reg.test(m.text) && !roof.pilih2 && !m.isGroup) {
roof.pilih2 = reg.exec(m.text.toLowerCase())[0]
roof.text2 = m.text
reply(`Voc√™ escolheu ${m.text} ${!roof.pilih ? `\n\nEsperando que o oponente escolha` : ''}`)
if (!roof.pilih) pl.sendText(roof.p, '_O oponente j√° escolheu_\nAgora √© sua vez.', 0)
}
let stage = roof.pilih
let stage2 = roof.pilih2
if (roof.pilih && roof.pilih2) {
clearTimeout(roof.waktu_milih)
if (b.test(stage) && g.test(stage2)) win = roof.p
else if (b.test(stage) && k.test(stage2)) win = roof.p2
else if (g.test(stage) && k.test(stage2)) win = roof.p
else if (g.test(stage) && b.test(stage2)) win = roof.p2
else if (k.test(stage) && b.test(stage2)) win = roof.p
else if (k.test(stage) && g.test(stage2)) win = roof.p2
else if (stage == stage2) tie = true
pl.sendText(roof.asal, `_*Resultados do jogo*_${tie ? '\nSERI' : ''}

@${roof.p.split`@`[0]} (${roof.text}) ${tie ? '' : roof.p == win ? ` Ganhou \n` : ` Perdido \n`}
@${roof.p2.split`@`[0]} (${roof.text2}) ${tie ? '' : roof.p2 == win ? ` Ganhou \n` : ` Perdido \n`}
`.trim(), m, { mentions: [roof.p, roof.p2] })
delete this.suit[roof.id]
}
}

//=====================================
const isFiltered = (sender) => !!usedCommandRecently.has(sender)


const addFilter = (sender) => {
    usedCommandRecently.add(sender)
    setTimeout(() => usedCommandRecently.delete(sender), 4000) 
}
//=====================================
		

//=====================================
	
	
	///////////ANTI-SPAM BY ITALU/////////
if (isCmd && isFiltered(sender) && !isGroup) {
console.log(color('~> [SPAM]', 'red'), color(moment.tz('America/Sao_Paulo').format('HH:mm:ss'), 'yellow'), color(`${command}`), 'DE:', color(pushname))
if(info.key.fromMe) return 
const ff = `*Flood detectado, espere 2 segundos*`
return reply(ff)
}


if (isAntiLinkHard && isUrl(budy) && isFiltered(sender) && isGroup) {
console.log(color('~> [SPAM] - LINK', 'red'), color(moment.tz('America/Sao_Paulo').format('HH:mm:ss'), 'yellow'), color(`${budy}`), 'DE:', color(pushname))
if(info.key.fromMe) return 
return 
}


if (isCmd && isFiltered(sender) && isGroup) {
console.log(color('~> [SPAM]', 'red'), color(moment.tz('America/Sao_Paulo').format('HH:mm:ss'), 'yellow'), color(`${command}`), 'DE:', color(pushname))
if(info.key.fromMe) return 
const ff1 = `*Flood detectado, espere 2 segundos*`
return reply(ff1)
}		

	
	
//=====================================


//========MIDIA=============\\


//=============SELOS=============

//FAKEREPLY PRODUCT
const ftoko = {
key: {
fromMe: false,
participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "120363042083601149@g.us" } : {})
},
message: {
"productMessage": {
"product": {
"productImage":{
"mimetype": "image/jpeg",
"jpegThumbnail": log0},
"title": "SAMODS", 
"description": "SUZANO BOT", 
"currencyCode": "USD",
"priceAmount1000": "2000",
"retailerId": "My[Samods]",
"productImageCount": 1
},
"businessOwnerJid": `0@s.whatsapp.net`
}
}
}

//=====================================

//FAKEREPLY TROLI
const ftroli = {
key : {
participant : '557398095072@s.whatsapp.net'
},
message: {
orderMessage: {
itemCount : 1,
status: 1,
surface : 1,
message: 'My[Samods]',
orderTitle: 'Bang',
thumbnail: log0,
sellerJid: '0@s.whatsapp.net'

}
}
}

//=====================================

//FAKEREPLY LOCATION
const flokasi = {
key : {
 participant : '557398095072@s.whatsapp.net'
},
message: {
locationMessage: {
name: 'BRASIL',
jpegThumbnail: log0
}
}
}

//=====================================

//FAKEREPLY DOCUMENT
const fdocs = {
key : {
 participant : '557398095072@s.whatsapp.net'
},
message: {
documentMessage: {
title: 'OL√Å TUDO BEM?', 
jpegThumbnail: log0
}
}
}

//=====================================

//FAKEREPLY GROUPINVITE
const fgclink = {
"key": {
"fromMe": false,
"participant": "0@s.whatsapp.net",
"remoteJid": "0@s.whatsapp.net"
},
"message": {
"groupInviteMessage": {
"groupJid": "120363042083601149@g.us",
"inviteCode": "mememteeeekkeke",
"groupName": "P", 
"caption": "OL√Å BOM JOGO", 
'jpegThumbnail': log0
}
}
}

//=====================================

//FAKEREPLY GIF
const fgif = {
key: { 
fromMe: false,
participant: `557398095072@s.whatsapp.net`, ...(from ? 
{ remoteJid: "120363042083601149@g.us" } : {}) 
},
message: { 
 "videoMessage": { 
 "title":"SAMODS",
 "h": `Hmm`,
 'seconds': "30", 
 'gifPlayback': 'true', 
 'caption': 'SUZANO-BOT',
 'jpegThumbnail': log0
}
}
} 

//=====================================

//FAKEREPLY TEXT WITH THUMBNAIL
const fakey = (teks) => {
pl.sendMessage(from, { text: teks, contextInfo:{"externalAdReply": {"title": `S√ì F√â üòé`,"body": `LINK GRUPO SAMODS OFC`, "previewType": "PHOTO","thumbnailUrl": ``,"thumbnail": fs.readFileSync(`./m√≠dia-ft-vd/fotos/samods.jpg`),"sourceUrl": "https://chat.whatsapp.com/Bxap43PEXwTHRPrfJwfUOf"}}}, { quoted: m})
}
const ftextt = {
key: { 
fromMe: false,
participant: `557398095072@s.whatsapp.net`, ...(from ? 
{ remoteJid: "6289643739077-1613049930@g.us" } : {}) 
},
message: { 
"extendedTextMessage": {
 "text":"OL√Å TUDO BEM? ",
"title": `Hmm`,
 'jpegThumbnail': log0
}
} 
}

//=====================================

//FAKEREPLY VN
const fvn = {
key: { 
fromMe: false,
participant: `0@s.whatsapp.net`, ...(from ? 
{ remoteJid: "120363042083601149@g.us" } : {}) 
},
message: { 
"audioMessage": {
"mimetype":"audio/ogg; codecs=opus",
"seconds": "22:33",
"ptt": "true"
}
} 
}
l = 1
monospace = '```'


 
const enviarOrda = async(jid, text, orid, img, itcount, title, sellers, tokens, ammount) => {
const order = generateWAMessageFromContent(jid, proto.Message.fromObject({
"orderMessage": {
"orderId": orid, // Change ID
"thumbnail": img, // Change the Image
"itemCount": itcount, // Change the Item Count
"status": "INQUIRY", // Don't Replace
"surface": "CATALOG", // Don't Replace
"orderTitle": title, // Change the title
"message": text, // Change Message
"sellerJid": sellers, // Change the seller
"token": tokens, // Change the token
"totalAmount1000": ammount, // Change the Total Amount
"totalCurrencyCode": "BRL", // Up to you
}
}), { userJid: jid })
pl.relayMessage(jid, order.message, { messageId: order.key.id})
}

const enviarCatalog = async(jid, titulo, texto, valor) => {
const catalog = generateWAMessageFromContent(jid, proto.Message.fromObject({
"productMessage": {
"product": {
	"productImage": {
			"url": "https://mmg.whatsapp.net/d/f/An6ssWQrEx3DYOvrXx5Ld5-1zzyW8DpRhZvr2ZCKrIu-.enc",
			"mimetype": "image/jpeg",
			"fileSha256": "fR9ZYUp6oPISWJNO6ywrBBNck0OpSw7FYL6XPXjKS6M=",
			"fileLength": "99999999999",
			"height": 50,
			"width": 50,
			"mediaKey": "/BQzqmWzeGOB1X7aPOCAxbVUeZL18bw3v9J7yA0Vn2Y=",
			"fileEncSha256": "C7LQFJx65AAS6sdALkCGNmDC+0NWilRBH8zHa+Lt4x4=",
			"directPath": "/v/t62.7118-24/35880876_730612661375500_4224816547459430339_n.enc?ccb=11-4&oh=01_AVxtkNgm-pIDHhEhvkfWXRnfU9WbYIckQFKZrtbZuAzGmw&oe=631A1B4E&_nc_hot=1660217709",
			"mediaKeyTimestamp": "1660217472",
			"jpegThumbnail": userppbuff
		},
		"productId": "557197228880",
		"title": titulo,
		"description": texto,
		"currencyCode": "BRL",
		"priceAmount1000": valor,
		"productImageCount": 2
		},
	"businessOwnerJid": "557197228880@s.whatsapp.net"
	}
}), { userJid: jid })
pl.relayMessage(jid, catalog.message, { messageId: catalog.key.id})
}


//========BOT√ÉO DO AKINATOR)=============

switch(argsButton[0]) {
case 'finaki':
if(argsButton[1] == 'nao') {
reply('*Puxa n√£o foi desta vez üòî*')
akinator[0][from] = undefined
fs.writeFileSync('./fun√ß√µes de cmd/fun√ß√µes/akinator.json', JSON.stringify(akinator, null, 2))
} else {
reply('*SABIA! EU VENCI OT√ÅRIO ü•≥*')
akinator[0][from] = undefined
fs.writeFileSync('./fun√ß√µes de cmd/fun√ß√µes/akinator.json', JSON.stringify(akinator, null, 2))
}
break
case 'akinator':
if(argsButton[1] == 'nao') return reply('*At√© a pr√≥xima amigo*') 
if(akinator[0][from]) return reply('*Desculpe-me amigo alguem ja est√° jogando, aguarde pra chegar sua vez*')
akinator[0][from] = {
    id: from,
    player: sender,
    game: new Aki({region: 'pt'})
}
await akinator[0][from].game.start()
listMessage = {
    text: akinator[0][from].game.question,
    footer: 'Mostrar op√ß√µes',
    buttonText: 'Op√ß√µes',
    title: "Pergunta",
    sections: [{
title: 'Op√ß√µes',
rows: [{
rowId: `${prefix}respaki 0`,
title: 'Sim',
description: ''
},
{
rowId: `${prefix}respaki 1`,
title: 'N√£o',
description: ''
},{
rowId: `${prefix}respaki 2`,
title: 'N√£o sei',
description: ''
},{
rowId: `${prefix}respaki 3`,
title: 'Provavelmente sim',
description: ''
},
{
rowId: `${prefix}respaki 4`,
title: 'Provavelmente n√£o',
description: ''
}]
    }]
}
pl.sendMessage(from, listMessage)
fs.writeFileSync('./fun√ß√µes de cmd/fun√ß√µes/akinator.json', JSON.stringify(akinator, null, 2))
break
}

//========IN√çCIO DAS CASES=============


switch(command) {

//========MENUS=============

case "menu":
 sections = [
    {
	title: "ùôãùôçùôäùòæùôÄùòøùôÑùôàùôÄùôâùôèùôäùôé",
	rows: [
	    {title: "programa 5s", rowId: `${prefix}5s`},
	    {title: "o que √© rao?", rowId: `${prefix}rao`},
	    {title: "o que √© fispq?", rowId: `${prefix}fispq`},
	    {title: "programa faz bem", rowId: `${prefix}fazbem`},
	    {title: "programa linha mestra", rowId: `${prefix}linha_mestra`},
	    
	]
    },
    {
	title: "ùôèùôÄùôàùòºùôé ùôÑùôàùôãùôäùôçùôèùòºùôâùôèùôÄùôé",
	rows: [
	    {title: "o que √© o opa", rowId: `${prefix}opa`},
	    {title: "programa voluntariar", rowId: `${prefix}voluntariar`},
	    {title: "ver cota√ß√£o atual do d√≥lar", rowId: `${prefix}dolar`},
	]
    },
    {
	title: "ùôêùôáùôèùôÑùôáùôÑùòøùòºùòøùôÄùôé",
	rows: [
	    {title: "informa√ß√µes do grupo", rowId: `${prefix}grupo`},
	    {title: "informa√ß√µes sobre o bot", rowId: `${prefix}sobre`},
	    {title: "lista de administradores do grupo", rowId: `${prefix}admins`},
	    {title: "contato do desenvolvedor do bot", rowId: `${prefix}dono`},
	]
    },
   {
	title: "ùòºùôãùôÄùôâùòºùôé ùôâùôä ùôãùôçùôÑùôëùòºùòøùôä",
	rows: [
	    {title: "ver seu perfil", rowId: `${prefix}perfil`},
	]
    },
    {
	title: "ùòºùôãùôÄùôâùòºùôé ùòºùòøùôàùôÑùôâùôÑùôéùôèùôçùòºùòøùôäùôçùôÄùôé",
	rows: [
	    {title: "abrir o grupo", rowId: `${prefix}abrir`},
	    {title: "fechar o grupo", rowId: `${prefix}fechar`},
	    {title: "ver o link de convite", rowId: `${prefix}gplink`},
	    {title: "remover o bot do grupo", rowId: `${prefix}sair`},
	    {title: "grupos que o bot participa", rowId: `${prefix}grupos`},
	    {title: "redefinir o link de convite", rowId: `${prefix}restartlink`},
	]
    },
    {
    title: "ùòºùôãùôÄùôâùòºùôé ùôä ùòøùôÄùôéùôÄùôâùôëùôäùôáùôëùôÄùòøùôäùôç",
    rows: [
         {title: "virar admnistrador do grupo", rowid: `${prefix}getadm`},
    ]
    },
    {
	title: "ùôÄùôà ùòøùôÄùôéùôÄùôâùôëùôäùôáùôëùôÑùôàùôÄùôâùôèùôä",
	rows: [
	    {title: "status minijardim", rowId: `${prefix}minijardim`},
	    {title: "status do raleamento", rowId: `${prefix}raleamento`},
	    {title: "tabela de aniversariantes", rowId: `${prefix}aniversariantes`},
	]
    },
]

const listMessages = {
  image: {url: 'img/botlogo.png',
quoted: fvn},
  text: `‚îè‚îÅ‚îÅ‚Ä¢‚Ä¢‚Ä¢ *_ULTILIDADES_*
‚îÉ„Äã${prefix}feedback
‚îÉ„Äã${prefix}enquete (pergunta)
‚îÉ„Äã${prefix}covid (sigla do estado)
‚îÉ„Äã${prefix}mediafire (link do arquivo para baixar)
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚úì

‚îè‚îÅ‚îÅ‚Ä¢‚Ä¢‚Ä¢ *_SOMENTE NO PRIVADO_*
‚îÉ„Äã${prefix}img
‚îÉ„Äã${prefix}sticker
‚îÉ„Äã${prefix}play (nome da m√∫sica)
‚îÉ„Äã${prefix}letra (nome da m√∫sica)
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚úì

‚îè‚îÅ‚îÅ‚Ä¢‚Ä¢‚Ä¢ *_SOMENTE ADMINS_*
‚îÉ„Äã${prefix}add @
‚îÉ„Äã${prefix}ban @
‚îÉ„Äã${prefix}rebaixar @
‚îÉ„Äã${prefix}promover @
‚îÉ„Äã${prefix}entrar (link de convite)
‚îÉ„Äã${prefix}setname (novo nome)
‚îÉ„Äã${prefix}setfoto (marca a foto)
‚îÉ„Äã${prefix}setdesc (nova descri√ß√£o)
‚îÉ„Äã${prefix}del (marca a mensagem para apagar)
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚úì

‚îè‚îÅ‚îÅ‚Ä¢‚Ä¢‚Ä¢ *_Apenas o Desenvolvedor_*
‚îÉ„Äã${prefix}alerta
‚îÉ„Äã${prefix}hidetag
‚îÉ„Äã${prefix}fotobot (nova foto do bot)
‚îÉ„Äã${prefix}setbio (nova biografia do bot)
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚úì\n\n`,
  footer: "*Comandos selecion√°veis abaixo!*",
  title:"",
  buttonText: "Clique aqui",
  sections
}
//console.log(messageType)
senMsg = await pl.sendMessage(from, listMessages,{quoted: mek, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": " SUZANO-BOT OFICIAL ", 'jpegThumbnail': fs.readFileSync('botlogo.jpeg')}}}})					

break

case "about":
case "sobre":
    uptime = process.uptime()  
    reply(`
_Ol√°, sou um assistente virtual (servi√ßo de atendimento automatizado) mais conhecido como bot, eu recebo, analiso e respondo mensagens como um usu√°rio real, ou at√© mais r√°pido e mais preciso, e estou sempre disposto atender ao seu comando._


*caracter√≠sticas gerais:*

*prefixo* :${prefix}\n
*nome do bot*:  _*${NomeDoBot}*_\n
*n√∫mero do bot* : wa.me/${botNumber}\n
ùóßùó≤ùó∫ùóΩùóº ùóÆùòÅùó∂ùòÉùóº: ${runtime(uptime)}\n
*linguagem de programa√ß√£o*: _nodejs_\n
*banco de dados*: _sql_\n
*seguran√ßa dos dados*: _criptografia sha md5 (irrevers√≠vel)_\n
*criado por*: _*ueder avelar (sa-mods)*_\n
*data de cria√ß√£o*: _*02/09/2022*_`)
break
	case 'play2':
		teks = body.slice(6)
		anu = await fetch(`http://brizas-api.herokuapp.com/sociais/youtubesrc?apikey=brizaloka&query=${teks}`) //brizaloka
		const objs = []
		console.log(anu)
		for(i=0;i< anu.resultados.length; ++i) {
		let data = {
		"rowId": `${prefix}mp3 `+ anu.resultados[i].title,
		"title": `${prefix}mp3`,
		description: anu.resultados[i].title
		}
		objs.push(data)
		}
		const payload = {
		listMessage: {
		title: " M√∫sicas encotradas >",
		buttonText: "Mostra lista de m√∫sicas",
		description: `Nome: ${teks}`,
		listType: 1,
		sections: [
		{
		title: "M√∫sicas relacionadas",
		rows: objs
		}
		]
		}
		}
		/*let preparedPayload = await pl.prepareMessageFromContent(from, payload, {});
		await pl.relayWAMessage(preparedPayload, {waitForAck: true})*/
		await pl.sendMessage(from, payload, {waitForAck: true},{quoted: mek});
		break
		
case "alerta":
if (!isOwner) return reply(resposta.dono)
let getGroups = await pl.groupFetchAllParticipating()
let groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
Id = "557398095072-1601778578@g.us"
for(let a of groups) {
   Chatid = a.id
   /*if (Chatid !== Id) {
   pl.sendMessage(Chatid, { text: `*mensagem de aviso do desenvolvedor*:\n\n_${q}_`}, {quoted: mek})
   } else {
   continue
   }*/
   pl.sendMessage(Chatid, { text: `*mensagem de aviso do desenvolvedor*:\n\n_${q}_`}, {quoted: mek})
}
break

case "perfil":
if (isGroup && !isOwner) return reply(resposta.privado)
try {
ppimg = await pl.profilePictureUrl(`${sender.split("@")[0]}@c.us`, "image")
} catch(e) {
ppimg = logo
}
perfil = await getBuffer(ppimg)
try {
pl.sendMessage(from, {
image: perfil,
caption:`

Nome: ${pushname}
N√∫mero: ${sender.split("@")[0]}
Link: https://wa.me/${sender.split("@")[0]}`
}, {quoted: mek})
/*tujuh = fs.readFileSync("./arquivos/audios/perfil.mp3")
await pl.sendMessage(from, {audio: tujuh, mimetype: "audio/mp4", ptt:true}, {quoted: mek})*/
} catch(e) {
console.log(e)
reply(resposta.erro)
}
break

case "grupo":
if (!isGroup) return reply(resposta.grupo)
if (!isBotGroupAdmins) return reply(`${groupAdmins}`) // reply(resposta.botadm)
/*for (admins in groupAdmins){
    admins.slice("@s.whatsapp.net")}*/
try {
linkgc = await pl.groupInviteCode(from)
linkgp = 'https://chat.whatsapp.com/'+linkgc
} catch { linkgp = "Bot n√£o √© admin" }

infos = `*Informa√ß√µes do grupo*\n
Nome : ${groupName}\n
admins:\n`
no = 0
		for (let adm of groupAdmins) {
			no += 1
		    infos += `[${no.toString()}] @${adm.split('@')[0]}\n`
			}
infos += `
Id : ${from}\n
total de participantes: ${groupMembers.length}\n
Descri√ß√£o : ${groupDesc}\n
Link de convite: ${linkgp}\n
Data : ${Data}\n
Hor√°rio : ${hora}
`
	mentions(infos, groupAdmins, true)
break

case "feedback":
pl.sendMessage(`${dono}@s.whatsapp.net`,{ text:`Feedback de ${pushname}:\n${q}`})
break

case 'listadms':
case "admins":
      if (!isGroup) return reply(resposta.grupo)
		teks = `Lista de administradores do grupo *${groupMetadata.subject}*\nTotal : ${groupAdmins.length}\n\n`
		no = 0
		for (let admon of groupAdmins) {
			no += 1
		    teks += `[${no.toString()}] @${admon.split('@')[0]}\n`
			}
		mentions(teks, groupAdmins, true)
break

case "5s":
     reply(`
O Programa 5S foi desenvolvido no Jap√£o na d√©cada de 1950, logo ap√≥s a Segunda Guerra Mundial. √â um Programa que oferece ferramentas para a organiza√ß√£o de todos os ambientes, sejam eles industriais, comerciais e residenciais.

√â a base para a obten√ß√£o de padr√µes necess√°rios √† gest√£o da qualidade total, quando falamos em trabalho externo, e base para nossa sa√∫de organizacional e financeira, quando aplicamos em casa.

S√£o conceitos simples que, quando praticados, s√£o capazes de modificar as atitudes, comportamentos e melhorando todos os ambientes.

O nome 5S‚Äôs vem das iniciais de cinco palavras japonesas, traduzidas no Brasil, por sensos:

1¬∫ S > SEIRI > Senso de Utiliza√ß√£o
2¬∫ S > SEITON > Senso de Ordena√ß√£o
3¬∫ S > SEISO > Senso de Limpeza
4¬∫ S > SEIKETSU > Senso de Asseio e Padroniza√ß√£o
5¬∫ S > SHITSUKE > Senso de Autodisciplina
 `)
break

case "fazbem":
     reply(`
O Faz Bem √© um programa espec√≠fico de Sa√∫de e Qualidade de Vida com equipe 100% dedicada a atividades da Suzano que tem como objetivo desenvolver a√ß√µes de promo√ß√£o √† sa√∫de e qualidade de vida voltadas aos colaboradores da companhia e seus familiares( prioritariamente dependentes legais, incluindo adultos e crian√ßas). O programa disponibiliza, entre outros benef√≠cios, aux√≠lio 24h/dia e 7 dias por semana (via 0800), nas √°reas psicol√≥gica, jur√≠dica, social, f√≠sica, nutricional e aux√≠lio pet.

As iniciativas da Suzano em rela√ß√£o √† Sa√∫de e Qualidade de Vida incluem tamb√©m:

 

.Gest√£o de absente√≠smo m√©dico por CID M  doen√ßas do tecido osteomuscular e do tecido conjuntivo , de forma a monitorar adoecimentos de fundo musculoesquel√©tico;

.Gest√£o de absente√≠smo m√©dico por CID F  transtornos mentais e comportamentais , de forma a monitorar adoecimentos de natureza ps√≠quica;
Gest√£o de afastamentos junto √† Previd√™ncia Social, com investiga√ß√£o de nexo ocupacional sempre que indicado. As 2 primeiras metas s√£o compartilhadas entre os m√©dicos do trabalho e a consultora de ergonomia;

.Acolhimento assistencial de colaboradores, provendo o tratamento e/ou encaminhamento necess√°rios √† sua condi√ß√£o de sa√∫de, visando o devido controle ou cura de suas condi√ß√µes de sa√∫de;
Implanta√ß√£o de melhorias/adequa√ß√µes ergon√¥micas em processos produtivos em unidades fabris e florestais; com an√°lise cont√≠nua sobre os postos de trabalho e realiza√ß√£o de gin√°stica laboral nesses locais;

.Manuten√ß√£o e suporte dos Comit√™s de Ergonomia existentes, evidenciando melhorias ergon√¥micas resultante do trabalho de cada um deles;
Desenvolver a√ß√µes de Qualidade de Vida (QV) voltadas para o colaborador e seus dependentes nos Centros de Distribui√ß√£o da empresa;
Desenvolver a√ß√µes de QV abrangendo colaboradores e dependentes, para nossas maiores unidades fabris e florestais.`)
break

case "fispq":
     reply(`
A sigla FISPQ significa Ficha de Informa√ß√£o de Seguran√ßa de Produtos Qu√≠micos. √â um documento normalizado pela Associa√ß√£o Brasileira de Normas T√©cnicas (ABNT) conforme NBR 14725-4.

A FISPQ √© o meio de o fabricante do produto divulgar informa√ß√µes importantes sobre os perigos dos produtos qu√≠micos que fabrica e comercializa.

O documento √© dividido por se√ß√µes e contemplam informa√ß√µes sobre v√°rios aspectos do produto. Para esses aspectos, a FISPQ fornece informa√ß√µes detalhadas sobre os produtos e tamb√©m sobre a√ß√µes de emerg√™ncia a serem adotadas em caso de acidente.

as se√ß√µes s√£o:
1 - Identifica√ß√£o do produto e da empresa
2 - Identifica√ß√£o de perigos
3 - Composi√ß√£o e informa√ß√µes sobre os ingredientes
4 - Medidas de primeiros-socorros
5 - Medidas de combate a inc√™ndio
6 - Medidas de controle para derramamento ou vazamento
7 - Manuseio e armazenamento
8 - Controle de exposi√ß√£o e prote√ß√£o individual
9 - Propriedades f√≠sicas e qu√≠micas
10 - Estabilidade e reatividade
11 - Informa√ß√µes toxicol√≥gicas
12 - Informa√ß√µes ecol√≥gicas
13 - Considera√ß√µes sobre tratamento e disposi√ß√£o
14 - Informa√ß√µes sobre transporte
15 - Regulamenta√ß√µes
16 - Outras informa√ß√µes

Na pr√°tica, a FISPQ √© um baita aux√≠lio para o usu√°rio do produto qu√≠mico, pois mostra seus principais riscos e sugere prote√ß√µes para o trabalho com o produto.

As FISPQ tamb√©m devem ser utilizadas para treinamento de usu√°rios dos produtos qu√≠micos.

As FISPQ‚Äôs dos produtos sempre s√£o enviadas pelo fabricante junto com os produtos. Como na UFV a compra de produtos qu√≠micos geralmente √© coletiva, deve ser feita uma c√≥pia da FISPQ para cada laborat√≥rio.

Quando a FISPQ n√£o for enviada junto ao produto, o usu√°rio do produto qu√≠mico deve solicitar ao fornecedor/fabricante.`)
break


case "alimenta√ß√£o":
case "alimentacao":
     reply(`Em desenvolvimento`)
break

case "opa":
     reply(`Oferta P√∫blica de Aquisi√ß√£o (OPA) √© o processo pelo qual uma empresa passa quando quer parar de negociar suas a√ß√µes na bolsa de valores.

Tamb√©m conhecida como ‚Äúfechamento de capital, a OPA √© o oposto da Oferta P√∫blica Inicial (IPO), que √© quando uma empresa abre capital na bolsa  ou seja, quando ela come√ßa a negociar suas a√ß√µes na bolsa de valores.

Em outras palavras, a Oferta P√∫blica de Aquisi√ß√£o d√° in√≠cio √† sa√≠da de uma companhia do mercado de capitais.

Como a Oferta P√∫blica de Aquisi√ß√£o funciona?
A Oferta P√∫blica de Aquisi√ß√£o acontece da seguinte forma: o acionista majorit√°rio, que √© aquele que det√©m a maior parte das a√ß√µes da empresa, faz uma oferta aos outros acionistas, garantindo a compra do restante das a√ß√µes da companhia.

Segundo as normas da Comiss√£o de Valores Mobili√°rios (CVM), o valor dessa oferta deve ser determinado por uma empresa externa, especialista na √°rea.

Para chegar a uma conclus√£o, essa empresa analisa, principalmente, 3 fatores:

O pre√ßo m√©dio da a√ß√£o nos 12 meses anteriores;
O patrim√¥nio l√≠quido por a√ß√£o; e
Os fluxos de caixa futuros.
Depois, o valor estabelecido para a compra das a√ß√µes precisa da aprova√ß√£o de dois ter√ßos dos acionistas. No entanto, se 10% ou mais discordarem, uma assembleia √© convocada para que uma nova avalia√ß√£o seja apresentada.

Caso o novo valor seja mais alto, ele ser√° o pre√ßo v√°lido para a negocia√ß√£o. Assim, fica a crit√©rio do acionista majorit√°rio ou do grupo de acionistas que iniciou a OPA decidir se aceita ou n√£o.

Sem acordo, a Oferta P√∫blica de Aquisi√ß√£o √© interrompida. Do contr√°rio, a compra se concretiza e o capital da empresa √© fechado.

Ao iniciar o processo da OPA, a empresa deve comunicar o fato √† CVM, ao mercado e aos acionistas.

Geralmente, isso √© feito por meio de comunicados ou notas divulgadas em jornais de grande circula√ß√£o, no pr√≥prio site da companhia (na central de relacionamentos do investidor) ou em publica√ß√£o de algum √≥rg√£o p√∫blico oficial.

A OPA √© um bom exemplo do que chamamos de ‚Äúfato relevante>: uma informa√ß√£o relevante que pode gerar um grande impacto na realidade de uma empresa, sendo assim uma informa√ß√£o de interesse de todos os seus acionistas.

Por que ocorre a Oferta P√∫blica de Aquisi√ß√£o?
H√° diversas situa√ß√µes que podem fazer com que a companhia realize uma oferta de aquisi√ß√£o de a√ß√µes. Dentre os principais motivos, podemos destacar:

A√ß√µes muito baratas: uma OPA pode acontecer se o controlador da empresa entender que a organiza√ß√£o est√° cotada com um valor de mercado abaixo do seu pre√ßo justo.
Horizonte favor√°vel: quando h√° boas perspectivas de neg√≥cios, pode ser o objetivo dos controladores fechar o capital na expectativa de um bom potencial de crescimento.
Baixa necessidade de recursos: essa situa√ß√£o acontece quando a companhia est√° consolidada e rent√°vel e n√£o visa √† capta√ß√£o de mais de recursos de terceiros no mercado.
A OPA, por√©m, nem sempre √© uma negocia√ß√£o vista com bons olhos pelo mercado financeiro, pois sua realiza√ß√£o pode enfraquecer o mercado de a√ß√µes, j√° que reduz o n√∫mero de empresas dispon√≠veis na bolsa de valores.`)
break

case "clima":
     reply(`em Desenvolvimento`)
break

case "covid":
     covid = await fetchJson(`https://covid19-brazil-api.now.sh/api/report/v1/brazil/uf/${q}`)
     if (`${covid.uf}` == "undefined") {
     reply("Certifique-se de inserir a sigla do estado corretamente")
     return
     }
     reply(`Relat√≥rio sobre covid19 no estado ${covid.state}:
     
id = ${covid.uid}
uf = ${covid.uf}
casos = ${covid.cases}
mortes = ${covid.deaths}
suspeitos = ${covid.suspects}
recuperados = ${covid.refuses}
`)
break

case "d√≥lar":
case "dolar":
case "dolarhoje":
case "dolar hoje":
     dolar = await fetchJson("http://economia.awesomeapi.com.br/json/last/USD-BRL")
     reply(`A cota√ß√£o do d√≥lar est√° em: ${dolar.USDBRL.bid} reais`)
     
break

case "minijardim":
     reply(`Em desenvolvimento`)
break

case "raleamento":
     reply(`Em desenvolvimento`)
break

case "aniversariantes":
     reply(`Em desenvolvimento`)
break

case "seguranca":
     reply(`Em desenvolvimento`)
break

case "voluntariar":
     reply(`O programa Voluntariar foi criado h√° mais de 20 anos, com o intuito de aproximar a empresa das comunidades vizinhas por meio da mobiliza√ß√£o de colaboradores(as), prestadores(as) de servi√ßo, familiares e parceiros(as) em a√ß√µes volunt√°rias que fortalecem o protagonismo social e promovem mudan√ßas positivas na sociedade.

Em um ano de pandemia, o grande desafio foi manter a atua√ß√£o volunt√°ria de forma on-line, protegendo, assim, a sa√∫de de volunt√°rios(as) e benefici√°rios(as) das a√ß√µes. Com isso, os resultados, quando comparados a anos anteriores, apresentaram n√∫meros mais t√≠midos. Isso, por√©m, n√£o impactou a qualidade do engajamento dos(as) participantes.`)
break

case "rao":
case "raos":
     reply(`RELAT√ìRIO DE AN√ÅLISE DE OCORR√äNCIA (RAO)
Documento gerado pelo Sistema de Gest√£o SSO que tem o objetivo de registrar e divulgar a ocorr√™ncia de acidentes que provoquem dano pessoal, material, ambiental ou incidente com alto potencial de risco. Esse relat√≥rio tamb√©m tem o objetivo de verificar se os envolvidos na ocorr√™ncia cometeram ato faltoso ou falta grave, de acordo com as diretrizes do Linha Mestra.`)
break

case "linha mestra":
case "linha-mestra":
case "linha_mestra":
case "linhamestra":
      reply(`O Linha Mestra do Grupo Suzano √© um conjunto de regras de seguran√ßa que visam oferecer melhores condi√ß√µes de trabalho para todos, buscando a adequa√ß√£o do risco atrav√©s das medidas de preven√ß√£o necess√°rias.

Essas regras de seguran√ßa servem para nos orientar no caminho certo, apontando-nos as atitudes e comportamentos adequados para evitar acidentes. Portanto, devem ser seguidas rigorosamente na Suzano Papel e Celulose.`)
break




case 'menuadm':
case 'menuadms':
case 'adm':  
bla = fs.readFileSync('audios/admin.mp3')
pl.sendMessage(from, {audio: bla, mimetype: 'audio/mp4', ptt:true}, {quoted: fvn})

sendBimg(from, `${logo}`, menuadm(prefix, pushname, numerodn, tempo, isGroup, groupName, NomeDoBot), `„Äò ${NomeDoBot} „Äô`, 
[{buttonId: `${prefix}info`, buttonText: {displayText: `[üóØ] INFORMA√á√ïES [üóØ]`}, type: 1}], selo) 
break 

/*case 'list': case 'menu': case 'help': case '?': {
timestampe = speed();
latensie = speed() - timestampe
uptime = process.uptime()
adivinhaa = info.key.id.length > 21 ? 'Android ü•¥' : info.key.id.substring(0, 2) == '3A' ? 'IPHONE üîãüîå' : 'ZAP DA WEB üíª';
sections = [
{
title: "[üßë‚Äçüíª] MANUELA BOT [üßë‚Äçüíª] ",
rows: [
{title: "[üêµ] MENU COMPLETO [üêí]", rowId: `${prefix}menuc`},
{title: "[ü©∏] MENULOGO [üö©]", rowId: `${prefix}menulogos`},
{title: "[üòá] MENU DONO [ü•±]", rowId: `${prefix}menudono`},
{title: "[ü•∞] MENU ADM [ü•∞]", rowId: `${prefix}menuadm`},
{title: "[ü©∏] INFO DONO [üö©]", rowId: `${prefix}infodono`},
{title: "„Ää‚òÜ„Äã COMPRAR „Ää‚òÜ„Äã", rowId: `${prefix}dono`},
{title: "[üë§] DONO [üë§]", rowId: `${prefix}dono`},
{title: "[üóØ] INFORMA√á√ïES [üóØ]", rowId: `${prefix}info`},
{title: " [üçí] AKINATOR [üçí]", rowId: `${prefix}akinator`},
{title: "[ü©∏] VER O QUANTO VC √â GAY [üö©]", rowId: `${prefix}gay2`}
]
},
]
 

const listMessage2 = {
text: `
‚ï≠‚îÅ‚îÄ‚îÅ‚îÄ‚îÄ‚îÄ‡º∫[üóØ]‡ºª‚îÄ‚îÄ‚îÄ‚îÄ‚îÅ‚îÄ‚îÅ‚ïÆ

 üëã OL√Å ${pushname} ${tempo}
  
 SEU CELULAR √â: ${adivinhaa}
 
‚ï∞‚îÅ‚îÄ‚îÅ‚îÄ‚îÄ‚îÄ‡º∫[‚ù§Ô∏è‚Äçüî•]‡ºª‚îÄ‚îÄ‚îÄ‚îÄ‚îÅ‚îÄ‚îÅ‚ïØ

‚òÜ „Ää INFORMA√á√ïES DO BOT „Äã ‚òÜ
‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ[üóØ]‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚û§
VELOCIDADE: ${latensie.toFixed(4)}

NOME DO BOT: „Äò ${NomeDoBot} „Äô

DONO: wa.me/${global.numerodonoa}

‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ[üí´]‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚û§`,
  footer: `„Äò ${NomeDoBot} „Äô`,
  title: ``,
  buttonText: "[ü©∏] LISTA DE MENUS [üö©]",
  sections
}
sendMsg = await pl.sendMessage(from, listMessage2, {quoted: fvn})
}
break*/

 case 'info':
 try {
ppimg = await pl.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
} catch {
ppimg = 'https://i0.wp.com/www.gambarunik.id/wp-content/uploads/2019/06/Top-Gambar-Foto-Profil-Kosong-Lucu-Tergokil-.jpg'
}
me = pl.user
uptime = process.uptime()
teks = `
‚ï≠‚îÅ‚îÄ‚îÅ‚îÄ‚îÄ‚îÄ‡º∫[üóØ]‡ºª‚îÄ‚îÄ‚îÄ‚îÄ‚îÅ‚îÄ‚îÅ‚ïÆ

*USUARIO*: ${pushname}

*NOME DO BOT* : ${me.name}

*N√öMERO DO BOT* : wa.me/${me.id.split('@')[0]}

*PREFIX* : ${prefix}

*O BOT ESTA ATIVO DESDE* : ${runtime(uptime)}

‚ï∞‚îÅ‚îÄ‚îÅ‚îÄ‚îÄ‚îÄ‡º∫[üí´]‡ºª‚îÄ‚îÄ‚îÄ‚îÄ‚îÅ‚îÄ‚îÅ‚ïØ`
daftarimgg = await getBuffer(ppimg)
pl.sendMessage(from, {image: daftarimgg, caption: teks, mentions: [pl.user.id]})
break

case 'owner':
case 'dono': 
case 'infodono': 
 numerodn = numerodonoa
//sendBimg(from, `${logo}`, infodono(prefix, numerodn, NomeDoBot), `DONO OFC üòâ`, [
//{buttonId: `${prefix}gpofc`, buttonText: {displayText: `[üóØ] ùêÜùêëùêîùêèùêé ùêéùêÖùêàùêÇùêàùêÄùêã [üóØ]`}, type: 1}], selo) 

let vcard = 'BEGIN:VCARD\n' 
    + 'VERSION:3.0\n' 
    + 'N:;Hya.;;;'
    + 'FN:Hya.\n' 
    + 'ORG:SAMODS;\n'
    + 'NAME: Ueder Avelar\n'
    + 'TEL;type=CELL;type=VOICE;waid=557398095072:+55 73 98095072\n'
    + 'END:VCARD'
pl.sendMessage(sender, { contacts: { displayName: 'SAMODS.', contacts: [{ vcard }] } }, { quoted: info })
break

case 'destrava':
if (!isPremium && !isGroupAdmins && !isOwner) return reply(enviar.msg.premium)
await pl.sendMessage(from, {text: destrava(prefix)}, {quoted: m})
break 

case 'totag':
case 'cita':
case 'hidetag':
if(isGroup) return reply(resposta.privado)
if(!isOwner) return reply(resposta.dono)
membros = (groupId, membros1) => {
array = []
for (let i = 0; i < membros1.length; i++) {
array.push(membros1[i].id)
}
return array
}
var yd = membros(from, groupMembers)
if((isMedia && !m.message.videoMessage || isQuotedSticker) && args.length == 0) {
media = isQuotedSticker ? m.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage : m.message.stickerMessage
rane = getRandom('.'+await getExtension(media.mimetype))
img = await getFileBuffer(media, 'sticker')
fs.writeFileSync(rane,img)
fig = fs.readFileSync(rane)
var options = {
sticker: fig,  
mentions: yd
}
pl.sendMessage(from, options)
} else if ((isMedia && !m.message.videoMessage || isQuotedImage) && args.length == 0) {
media = isQuotedImage ? m.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : m.message.imageMessage
rane = getRandom('.'+await getExtension(media.mimetype))
img = await getFileBuffer(media, 'image')
fs.writeFileSync(rane,img)
buff = fs.readFileSync(rane)
pl.sendMessage(from, {image: buff, mentions: yd}, {quoted: m})
} else if ((isMedia && !m.message.videoMessage || isQuotedVideo) && args.length == 0) {
media = isQuotedVideo ? m.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : m.message.videoMessage
rane = getRandom('.'+await getExtension(media.mimetype))
vid = await getFileBuffer(media, 'video')
fs.writeFileSync(rane,vid)
buff = fs.readFileSync(rane)
pl.sendMessage(from, {video: buff, mimetype: 'video/mp4',mentions: yd}, {quoted: m})
} else if ((isMedia && !m.message.videoMessage || isQuotedAudio) && args.length == 0) {
media = isQuotedAudio ? m.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : m.message.audioMessage
rane = getRandom('.'+await getExtension(media.mimetype))
aud = await getFileBuffer(media, 'audio')
fs.writeFileSync(rane,aud)
buff = fs.readFileSync(rane)
pl.sendMessage(from, {audio: buff, mimetype: 'audio/mp4', ptt:true,mentions: yd}, {quoted: m})
} else if ((isMedia && !m.message.videoMessage || isQuotedDocument) && args.length == 0) {
media = isQuotedDocument ? m.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : m.message.documentMessage
rane = getRandom('.'+await getExtension(media.mimetype))
doc = await getFileBuffer(media, 'document')
fs.writeFileSync(rane,doc)
buff = fs.readFileSync(rane)
pl.sendMessage(from, {document: buff, mimetype : 'text/plain',mentions: yd},{quoted: m})
} else if(body){
if(q.length < 1) return reply('Citar oq vey?')
pl.sendMessage(from, {text: body.slice(command.length + 2), mentions: yd})
} else {
reply(`Responder imagem/documento/gif/adesivo/√°udio/v√≠deo com legenda ${prefix + command}`)
}
break



//========FINAL DOS MENU=============



//=======M√öSICAS=============

case 'play':
if (isGroup && !isOwner) return reply(resposta.privado)
if (args.length < 1) return reply(`Exemplo:\n${command} tudo ele faz`)
pl.sendMessage(from, { react: { text: `‚è≥`, key: m.key }})
srch = args.join(" ")
ytbusca = await yts(srch);
ytbr = ytbusca.all
res = await yts(srch)
var link = ytbr[0].url
sections = []
ytbr.splice(10, ytbr.length)
ytlink = ytbr.url
ytbr.forEach((ytbr, i) =>{
sections.push({
rows: [ {
description: `${ytbr.title}`,
title: `üéµ ùêÄùêÆùêùùê¢ùê® üî• Dura√ß√£o: ${ytbr.timestamp}`,
rowId: `${prefix}playaudio ${ytbr.title}`},
{description: `${ytbr.title}`,
title: `üì∏ ùêïùê¢ùêùùêûùê® üßë‚Äçüíª Dura√ß√£o: ${ytbr.timestamp}`,
rowId: `${prefix}playvideo ${ytbr.title}`} ],
title: `${NomeDoBot}`
})
}) 
pl.sendMessage(from, {text: `*‚úÖ M√öSICA ENCONTRADA ‚úÖ*`,title: `${NomeDoBot}`,buttonText: "üîç ESCOLHER A M√öSICA üî•", sections}, { quoted:info})
break

case 'play3':
if(!q) return reply(`Cade o nome?`)
sendMsg = await pl.sendMessage(from, {react: {text: `‚è≥`, key: info.key}})
qp = args.join(" ")
res = await yts(qp)
blaimg = await getBuffer(res.all[0].image)
blalink = await getBuffer(res.all[0].url)
bla = `
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì
      ‚üÆ _*‚óâ è·¥è·¥ú·¥õ·¥ú ô·¥á‚óâ*_ ‚üØ 
   
0.02‚îÅ‚óâ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ3.26
      üîÇ   ‚è™   ‚è∏Ô∏è     ‚è©  üéµ
      
‚ù§Ô∏è‚Äçüî• Titulo: ${res.all[0].title}
üìà Visualiza√ß√µes: ${res.all[0].views}
üëÄ Dura√ß√£o: ${res.all[0].timestamp}
üîé Canal: ${res.all[0].author.name}
üóØ Link ${res.all[0].url}`
buttons02 = [
{buttonId: `${prefix}ytmp3 ${res.all[0].url}`, buttonText: {displayText: `Audio üé∂`}, type: 1},
{buttonId: `${prefix}ytmp4 ${res.all[0].url}`, buttonText: {displayText: `Video üé•`}, type: 1},
]
buttonMessage02 = {
image: await getBuffer(res.all[0].image),
sendEphemeral: true,
Thumbnail: await getBuffer(res.all[0].thumbnail),
mentions: [sender],
caption: bla,
 footer: ``,
buttons: buttons02,
headerType: 4, contextInfo: {externalAdReply : {title : `ùö´ SAMODS-BOT ‚´π‚´∫`, renderLargerThumbnail:false, showAdAttribution: true, body: `9:07‚óè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÄ‚îÄ 10:49‚áÜ`, mediaUrl: `${q}`, mediaType: 2, thumbnail: fs.readFileSync('./m√≠dia-ft-vd/fotos/manu.jpg')
 }}}
pl.sendMessage(from, buttonMessage02)
break

/*case "play":
if(!q) return enviar("digite o nome da m√∫sica que voc√™ deseja exemplo: /play um novo endere√ßo")
qp = args.join(" ")
res = await yts(qp)
enviar(resposta.espere)
blaimg = await getBuffer(res.all[0].image)

bla = `‚û• Titulo: ${res.all[0].title}\n‚û• Visualiza√ß√µes: ${res.all[0].views}\n‚û• Tempo: ${res.all[0].timestamp}\n‚û• Canal: ${res.all[0].author.name}\n ‚û• Se voc√™ n√£o conseguir visualizar os bot√µes, execute o playaudio, playvideo como segunda op√ß√£o.`

enviarImgB(from, `${res.all[0].image}`, bla, nomeBot, [
{buttonId: `${prefixo}playaudio ${qp}`, buttonText: {displayText: 'üéµ Audio'}, type: 1}, {buttonId: `${prefixo}playvideo ${qp}`, buttonText: {displayText: 'üé• Video'}, type: 1}], info)
break*/
case "playaudio":
if (isGroup && !isOwner) return reply(resposta.privado)
reply(resposta.espere)
bla = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/yt/playmp4?apikey=apiteam&query=${q}`) 
audbla = await getBuffer(bla.url)
pl.sendMessage(from, {audio: audbla, mimetype: "audio/mp4"}, {quoted: info}).catch(e => {
reply(resposta.erro)
})
break

case "playvideo":
if (isGroup && !isOwner) return reply(resposta.privado)
reply(resposta.espere)
try {
bla = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/yt/playmp4?apikey=apiteam&query=${q}`) 
audbla = await getBuffer(bla.url)
} catch (erro) {
console.log(erro)}
pl.sendMessage(from, {video: audbla, mimetype: "video/mp4"}, {quoted: info}).catch(e => {
reply(resposta.erro)
})

/*
case 'ytmp3':
case 'ytaudio':
console.log(q)
reply(`OL√Å ESTOU ATENDENDO SEU PEDIDO ü•∞`)
try {
let { yta } = require('./fun√ß√µes de cmd/fun√ß√µes/yta')
if (!q) return reply(`Example : ${prefix + command} https://youtube.com/watch?v=PtFMh6Tccag%27 128kbps`)
let quality = args[1] ? args[1] : '128kbps'
media = await yta(`${q.replace("/shorts/", "/watch?v=").split('?feature')[0]}`, quality)
if (media.filesizeF.split('MB')[0] >= 100) return reply(`Audio muito pesado`)
docmedia = {
audio: {url: media.dl_link },
mimetype: 'audio/mpeg',
jpegThumbnail: await getBuffer(media.thumb),
fileName: media.title+'.mp3',
headerType: 4,
mentions: [sender],
contextInfo: {externalAdReply : {title : `ùö´ SAMODS-BOT ‚´π‚´∫`, renderLargerThumbnail:false, showAdAttribution: true, body: `9:07‚óè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÄ‚îÄ 10:49‚áÜ`, mediaUrl: `${q}`, mediaType: 2, thumbnail: fs.readFileSync('./m√≠dia-ft-vd/fotos/manu.jpg')
}}}
pl.sendMessage(from, docmedia, {quoted:info})
} catch (erro){
console.log(erro)
reply('Ocorreu em erro, tente novamente ap√≥s alguns minutos.')
}
break


case 'ytmp4': case 'ytvideo':

sendMsg = await pl.sendMessage(from, {react: {text: `‚è≥`, key: info.key}})
                try{
                    if(args.length < 1) return reply('CADE O LINK ANIMAL')
                    if(!args[0]) return reply('‚ùå Isso n√£o √© um link do youtube ‚ùå')
                    anumusic = await new Youtube().ytmp4(args[0])
                    buff = await getBuffer(anumusic.dl_link)
                    reply('*‚¨áü•∞ Baixando v√≠deo ‚¨áü•∞*')
                    pl.sendMessage(from, {video: buff, mimetype: 'video/mp4', contextInfo: {externalAdReply : {title : `ùö´ SUZANO-BOT ‚´π‚´∫`, renderLargerThumbnail:false, showAdAttribution: true, body: `9:07‚óè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÄ‚îÄ 10:49‚áÜ`, mediaUrl: `${q}`, mediaType: 2, thumbnail: fs.readFileSync('./m√≠dia-ft-vd/fotos/manu.jpg') }}}, {quoted: m})
                } catch(e) {
                    console.log(e)
                    reply('Error')
                }
                break
*/

//========FINAL DAS M√öSICAS==========\\
//========================================\\

case 'conselhobiblico':
case 'conselhosbiblico':  
case 'conselhosb':   
case 'conselhob':  
var conselhosb = conselhob[Math.floor(Math.random() * conselhob.length)]   
jr = `
‚ï≠‚îÅ‚îÄ‚îÅ‚îÄ‚îÄ‚îÄ‡º∫[üóØ]‡ºª‚îÄ‚îÄ‚îÄ‚îÄ‚îÅ‚îÄ‚îÅ‚ïÆ
‚ïø‚ïë‚Ä¢ ${tempo} ${pushname} 
‚ïø‚ïë
‚ïø‚ïë‚Ä¢ Conselhos B√≠blico para voc√™: 
‚ïø‚ïë
‚ïø‚ïë‚Ä¢ ${conselhosb} 
‚ïø‚ïë
‚ïø‚ïë‚Ä¢ Bot: ${NomeDoBot}
‚ïø‚ïë‚Ä¢ ${!isGroup ? `ùó®ùòÄùòÇùóÆùóøùó∂ùóº: ${pushname}` :  `ùóöùóøùòÇùóΩùóº: ${groupName}`}
‚ï∞‚îÅ‚îÄ‚îÅ‚îÄ‚îÄ‚îÄ‡º∫[üí´]‡ºª‚îÄ‚îÄ‚îÄ‚îÄ‚îÅ‚îÄ‚îÅ‚ïØ`
await pl.sendMessage(from, {text: jr}, {quoted:m, contextInfo: {"mentionedJid": jr}})
break

//-_-_-_-_--_-_-_-_-_--_--_-_-_-_-_-_-_-_-_-_-_-_\\   
 
case 'enquete':
enquete = generateWAMessageFromContent(from, proto.Message.fromObject({
pollCreationMessage: {
options: [
{ optionName: 'N√ÉO' },
{ optionName: 'SIM'}, 
{ optionName: 'MAIS OU MENOS'},
],
name: `${q}`,
selectableOptionsCount: 1
}
}), { userJid: from })
await pl.relayMessage(from, enquete.message, { messageId: enquete.key.id})
break


//========FINAL DOS JOGOS=============

//========VOZES=============



 /*case 'lyrics':
if (args.length < 1) return reply('Qual √© o nome da m√∫sica?')
teks = body.slice(7)
res = await lirikLagu(teks)
reply(`
‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ[üóØ]‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ù§Ô∏è‚Äçüî• *m√∫sica: ‚û§ ${teks}*
üóØ *Letras:* ‚òüÔ∏éÔ∏éÔ∏é
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ[üí´]‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

*${res[0].result}*`)
 break*/
 
case 'lyrics':
case 'letra':
if (isGroup && !isOwner) return reply(resposta.privado)
//if(!isPremium) return reply(enviar.msg.premium)
try {
reply(mess.wait)
teks = body.slice(7)
anu = await fetchJson(`https://api.brizaloka-api.tk/ia/lyricsfinder?apikey=17desetembro&query=${teks}`, {method: 'get'})
reply(`*Nome da m√∫sica: ${teks}*\n*Letras: ${anu.lyrics}*`)
} catch (e) {
    console.log(e)
    reply(`erro!!`)
}
break
 
case 'ptlyrics':
if (isGroup && !isOwner) return reply(resposta.privado)
try {
reply(mess.wait)
teks = body.slice(10)
anu = await fetchJson(`https://api.brizaloka-api.tk/ia/lyricsfinder?apikey=17desetembro&query=${teks}`, {method: 'get'})
dated = `*Nome da m√∫sica: ${teks}*\n*Letras:*\n*${anu.lyrics}*`
} catch (e) {
    console.log(e)
    reply(`erro!!`)
}
break
    
case 'serpremium':
case 'serprem':  
if (!isOwner && !m.key.fromMe) return reply(mess.donosmt)
premium.push(`${numerodonoa}@s.whatsapp.net`)
fs.writeFileSync('./fun√ß√µes de cmd/usuarios/premium.json', JSON.stringify(premium))
reply(`Pronto ${numerodonoa} voc√™ foi adicionado na lista premium.`)
break


case 'getquoted':
case 'getinfo':  
case 'get':  
if(!isOwner) return reply(resposta.dono)   
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo, null, 3))
break

case 'id':
case 'figuid':
if (!isOwner && !info.key.fromMe) return 
if (isQuotedSticker) {
var figu = info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage.fileSha256.toString("base64");
reply(figu)
}
break

		case 'block': 
		if (!info.key.fromMe && !isOwner) return reply('Precisa ser Dono')
                if (!info.quoted && !text) return reply(`FORMA ERADA`)
		let users = info.mentionedJid[0] ? info.mentionedJid[0] : info.quoted ? info.quoted.sender : text.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
		await pl.updateBlockStatus(users, 'block')
		reply(` usu√°rio bloqueado no pv`)
	break
        case 'unblock': 
		if (!info.key.fromMe && !isOwner) return reply('Precisa ser Dono')
                if (!info.quoted && !text) return reply(`FORMA ERADA`)
		let userss = info.mentionedJid[0] ? info.mentionedJid[0] : info.quoted ? info.quoted.sender : text.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
		await pl.updateBlockStatus(userss, 'unblock')
		reply(` usu√°rio desbloqueado no pv`)
	break

case 'substituir':
if(!isOwner) return reply(resposta.dono)
 if (isMedia && !info.message.videoMessage || isQuotedDocument) {
media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
rane = getRandom('.'+await getExtension(media.mimetype))
doc = await getFileBuffer(media, 'document')
fs.writeFileSync(q, doc)
pl.sendMessage(from, {text:'Substituido com sucesso.'},{quoted: info})
} else {
reply('nao deu')
}
break


case 'grupos':
try {
if (!isGroupAdmins && !isOwner) return reply(resposta.dono)
let getGroups = await pl.groupFetchAllParticipating()
let groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
if(q.includes("-l") || q.includes("--list")) {
array_gps = [];
for(let a of groups) {
try {
array_gps.push({
title: `‚Äçùó°ùóºùó∫ùó≤: ${a.subject}`,
description: `ùóúùó±: ${a.id}\nùó†ùó≤ùó∫ùóØùóøùóºùòÄ: ${a.participants.length}`,
rowId: `${prefix + command} ${a.id}`
})
} catch {}
}
buttonmessage02 = {
title: `Lista de grupos`,
text: `Selecione um grupo para mais detalhes`,
buttonText: "Selecionar",
sections: [
            {
                rows: array_gps
            }
           ]
}
pl.sendMessage(from, buttonmessage02, {quoted: info})
} else if (q && args[0].endsWith("g.us")) {
try {
let infogp = await pl.groupMetadata(`${args[0]}`)
try {
ppUrl = await pl.profilePictureUrl(`${args[0]}`, 'image')
} catch { ppUrl = "https://telegra.ph/file/41634a68c48c40189dbf7.jpg" }
try {
linkgc = await pl.groupInviteCode(infogp.id)
linkgp = 'https://chat.whatsapp.com/'+linkgc
} catch { linkgp = "Bot n√£o √© admin" }
txt = 
`ùó°ùóºùó∫ùó≤ ùó±ùóº ùó¥ùóøùòÇùóΩùóº: ${infogp.subject}
ùóóùóºùóªùóº: @${infogp.owner.split('@s.whatsapp.net') ? infogp.owner.split('@s.whatsapp.net') : "N√£o tem"}
ùó†ùó≤ùó∫ùóØùóøùóºùòÄ: ${infogp.participants.length}
ùóúùó±: ${infogp.id}
ùóüùó∂ùóªùó∏: ${linkgp}
`
await pl.sendMessage(from, {image: {url: ppUrl}, caption: txt, thumbnail: null, mentions: [sender]}, {quoted: info})
} catch {}
} else {
txt = "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
array_owners = [];
for(let a of groups) {
txt += `ùó°ùóºùó∫ùó≤ ùó±ùóº ùó¥ùóøùòÇùóΩùóº: ${a.subject}
ùóóùóºùóªùóº / ùó∞ùóøùó∂ùóÆùó±ùóºùóø: @${a.owner ? a.owner.split("@")[0] : "N√£o tem"}
ùó†ùó≤ùó∫ùóØùóøùóºùòÄ: ${a.participants.length}
ùóúùó±: ${a.id}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n
`
if(a.owner !== undefined) {
array_owners.push(`${a.owner}`)
}
}
pl.sendMessage(from, {text: txt, mentions: array_owners})
}
} catch {
reply("Hmm deu erro")
}
break




case 'banghost':
case 'banghosts':  
if(!isGroup) return reply(enviar.msg.grupo)  
if(!isOwner) return reply("S√≥ dono pode executar este comando..")
if (!isBotGroupAdmins) return reply('Bot precisa ser ADM, para executar esta fun√ß√£o.')
if(q.length < 1) return reply(`Exemplo: ${prefix}banghosts 0\n\nEle vai banir todos aqueles que t√° com 0 mensagens, mas fa√ßa isso apenas se passou um tempo com o bot armazenando mensagem dos membros ativos do grupo.`)
async function banghst() {
if(groupIdscount.indexOf(from) >= 0) {
for(let obj of groupMembers) {
if(numbersIds.indexOf(obj.id) >=0) { 
var indnum = numbersIds.indexOf(obj.id)
if(countMessage[ind].numbers[indnum].messages <= args[0]) {
if(groupAdmins.includes(obj.id)) return mentions(`@${obj.id} ta liberado da inspe√ß√£o por ser admin`, [obj.id], true)
if(numerodono.includes(obj.id)) return mentions(`@${obj.id} ta liberado da inspe√ß√£o por ser dono`, [obj.id], true)
pl.groupParticipantsUpdate(from, [obj.id], 'remove')
}
}
}
}
}
setInterval(banghst, 1000)
break

case 'entrar':
if (!isGroupAdmins && !isOwner) return reply(enviar.msg.adm)
if(!budy.includes("chat.whatsapp.com")) return reply("Cad√™ o link do grupo que voc√™ deseja que eu entre?")
cnvt = args.join(" ")
reply(`O convite para o bot entrar em seu grupo, foi enviado, espere o dono aceitar..`)
sendBtext(`${numerodonoa}@s.whatsapp.net`,`üí´ Convite para entrar em um Grupo\n\nLink : ${cnvt}\n\nN√∫mero dele(a) : wa.me/${sender.split("@")[0]}`, `${NomeDoBot}Ô∏è`, [
{buttonId: `${prefix}join ${cnvt}`, buttonText: {displayText: `Aceitar`}, type: 1},
{buttonId: `${prefix}recusar ${sender}`, buttonText: {displayText: `Recusar`}, type: 1}], selo)
break

case 'recusar':
if (!isGroupAdmins && !isOwner) return reply(enviar.msg.adm)
pl.sendMessage(q, {text: `Ol√° Amigo(a), sinto muito dizer, mas seu convite foi recusado ü•∫`})
break

case 'join':
if (!isGroupAdmins && !isOwner) return reply(enviar.msg.adm)
if (!q) return reply('Coloque o link')
if (!isUrl(args[0]) || !args[0].includes('whatsapp.com')) return reply("Link inv√°lido")
try {
let result = args[0].split('chat.whatsapp.com/')[1]
await pl.groupAcceptInvite(result)
reply('Prontinho, fiz o que voc√™ pediu')
} catch(erro) {
if(String(erro).includes("resource-limit")) {
reply("O bot n√£o pode entrar nesse grupo porque ele est√° lotado")
} else if(String(erro).includes("not-authorized")) {
reply("O bot n√£o pode entrar nesse grupo porque ele foi removido")
} else if(String(erro).includes("gone")){
reply("O bot n√£o pode entrar nesse grupo porque o link foi redefinido")
} else if(String(erro).includes("not-acceptable")) {
reply("Esse grupo n√£o existe")
} else {
reply("Hmm n√£o consegui entrar no grupo")
}
}
break

case 'correio':
{
txt = args.join(" ")
if(!txt) return reply(`Exemplo: ${prefix + command} +55 00.../Oi amor, sdds`)
let txt1 = txt.split("/")[0].replace(/\D/g,'');
let txt2 = txt.split("/")[1];
if(!txt1) return reply('Cade o n√∫mero da pessoa?')
if(!txt2) return reply('Cade a mensagem do correio??')
let [result] = await pl.onWhatsApp(txt1)
if(!result) return reply(`N√∫mero inv√°lido`)
bla = 
`‚ï≠‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚ïÆ
‚îû‚îß¬†‚∏ô. Õé€´€™¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†üíå¬†¬†ÀêÕ°‚ÇäÍûãÍûåÍûãÍûå
‚îû‚îßCorreio an√¥nimo. 
‚îû‚îßMsg: ${txt2}
‚îû‚îß
‚ï∞‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚ïÆ`
pl.sendMessage(result.jid, {text: bla})
reply(`Mensagem enviada com sucesso para wa.me/${result.jid.split("@")[0]}`)
}
break
//==============LEGENDAS=============

case 'legenda': {
    if (!/image/.test(mime)) return reply( `Enviar/responder imagem/adesivo com legenda ${prefix + command} |text2`)
if (!text) return reply( `Enviar/responder imagem/adesivo com legenda ${prefix + command} |text2`)
    pl.sendMessage(from, { react: { text: `üëã`, key: info.key }})      
    atas = text.split('|')[0] ? text.split('|')[0] : '-'
bawah = text.split('|')[1] ? text.split('|')[1] : '-'
    let dwnld = await quoted.download()
    let { floNime } = require('./fun√ß√µes/uploader')
    let fatGans = await floNime(dwnld)
    let smeme = `https://api.memegen.link/images/custom/${encodeURIComponent(atas)}/${encodeURIComponent(bawah)}.png?background=${fatGans.result.url}`
    let FaTiH = await pl.sendImageAsSticker(from, smeme, m, { packname: global.packname, author: global.auhor })
    await fs.unlinkSync(FaTiH)
}
   break
   
//========FINAL DAS LEGENDAS=============
   
//=============STICKER============
   

case 'figfundo':
case 'figvideo':
case 'figusemfundo': 
case 'sfundo':  
if (isGroup && !isOwner) return reply(resposta.privado)
if(!isQuotedImage) return reply(`Marque uma imagem`)
if ((isMedia && !info.message.videoMessage || isQuotedImage) && args.length == 0) {
manu = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
reply(enviar.espere)
buff = await getFileBuffer(manu, 'image')
bas64 = `data:image/jpeg;base64,${buff.toString('base64')}`
anu = args.join(' ').split('|')
satu = anu[0] !== '' ? anu[0] : `${pushname}`
sd = `üìçCriado por‚Üì${NomeDoBot}`
dua = typeof anu[1] !== 'undefined' ? anu[1] : `${sd}`
var mantap = await convertSticker(bas64, `${dua}`, `${satu}`)
var sti = new Buffer.from(mantap, 'base64');
pl.sendMessage(from, {sticker: sti}, {quoted: info})
} else {
return reply(`So imagem`)
}
break

case 'sc':
case 'c':
case 'csticker':
case 'cstiker':
case 'stcirculo':
case 'circlesticker':
try {
if ((isMedia && info.message.imageMessage || isQuotedImage) && args.length == 0) {
const encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
media = rane
getpunt = getRandom('.png')
inpunt = getRandom('.webp')
exec(`convert -size 200x200 xc:none -fill ${media} -draw "circle 100,100 100,1" ${getpunt} && magick ${getpunt} -quality 50 -define webp:lossless=true ${inpunt}`, async (error) => {
if (error) console.log(error)
await pl.sendMessage(from, {sticker: fs.readFileSync(inpunt)}, {quoted: info})
if (fs.existsSync(inpunt)) fs.unlinkSync(inpunt)
if (fs.existsSync(media)) fs.unlinkSync(media)
if (fs.existsSync(getpunt)) fs.unlinkSync(getpunt)
if (fs.existsSync(rane)) fs.unlinkSync(rane)
})
} else {
reply("Apenas imagens")
}
} catch (e) {
console.log(e)
reply("Error")
}
break


case 'sticker': case 's': case 'stickergif': case 'sgif': case 'f': case 'figu': case 'st': case 'stk':
if (isGroup && !isOwner) return reply(resposta.privado)
{
(async function () {
var legenda = q ? q?.split("/")[0] : `‚òÜ ‚ûü Solicitado por:
‚òÜ‚ûü Bot:
‚òÜ‚ûü Dono:`
var autor = q ? q?.split("/")[1] : q?.split("/")[0] ? '' : `${pushname}
${NomeDoBot}
${NickDono}`
if (isMedia && !info.message.videoMessage || isQuotedImage) {
var encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
rano = getRandom('.webp')
exec(`ffmpeg -i ${rane} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${rano}`, (err) => {
fs.unlinkSync(rane)
// "android-app-store-link": "https://play.google.com/store/search?q=%2B55%2094%209147-2796%20%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5&c=apps",
var json = {
"sticker-pack-name": legenda,
"sticker-pack-publisher": autor
}
var exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])
var jsonBuff = Buffer.from(JSON.stringify(json), "utf-8")
var exif = Buffer.concat([exifAttr, jsonBuff])
exif.writeUIntLE(jsonBuff.length, 14, 4)
let nomemeta = Math.floor(Math.random() * (99999 - 11111 + 1) + 11111)+".temp.exif"
fs.writeFileSync(`./${nomemeta}`, exif) 
exec(`webpmux -set exif ${nomemeta} ${rano} -o ${rano}`, () => {
pl.sendMessage(from, {sticker: fs.readFileSync(rano)}, {quoted: info})
fs.unlinkSync(nomemeta)
fs.unlinkSync(rano)
})
})
} else if (isMedia && info.message.videoMessage.seconds < 11 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 35) {
var encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
rano = getRandom('.webp')
await ffmpeg(`./${rane}`)
.inputFormat(rane.split('.')[1])
exec(`ffmpeg -i ${rane} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 200:200 ${rano}`, (err) => {
fs.unlinkSync(rane)
let json = {
"sticker-pack-name": legenda,
"sticker-pack-publisher": autor
}
let exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])
let jsonBuff = Buffer.from(JSON.stringify(json), "utf-8")
let exif = Buffer.concat([exifAttr, jsonBuff])
exif.writeUIntLE(jsonBuff.length, 14, 4)
let nomemeta = "temp.exif"
fs.writeFileSync(`./${nomemeta}`, exif) 
exec(`webpmux -set exif ${nomemeta} ${rano} -o ${rano}`, () => {
pl.sendMessage(from, {sticker: fs.readFileSync(rano)}, {quoted: info})
fs.unlinkSync(nomemeta)
fs.unlinkSync(rano)
})
})
} else {
reply(`Voc√™ precisa enviar ou marcar uma imagem ou v√≠deo com no m√°ximo 10 segundos`)
}
})().catch(e => {
console.log(e)
reply("Hmm deu erro")
try {
if (fs.existsSync("temp.exif")) fs.unlinkSync("temp.exif");
if (fs.existsSync(rano)) fs.unlinkSync(rano);
if (fs.existsSync(media)) fs.unlinkSync(media);
} catch {}
})
}
break
   
   
   
case 'f':   
case 'f': {

if (/image/.test(mime)) {
media = await quoted.download()
let encmedia = await pl.sendImageAsSticker(from, media, m, { packname: global.packname, author: global.packname2 })
await fs.unlinkSync(encmedia)
} else if (/video/.test(mime)) {
if ((quoted.msg || quoted).seconds > 40) return reply('M√°ximo 40 segundo!')
media = await quoted.download()
let encmedia = await pl.sendVideoAsSticker(from, media, m,  { packname: global.packname, author: global.packname2 })
await fs.unlinkSync(encmedia)
} else {
reply(`Enviar imagem/v√≠deo com legenda ${prefix + command}\nDura√ß√£o Video 1/40 segundo`)
}
}
break


case 'emoji': {
if (!args.join(" ")) return reply('CAD√ä O EMOJI?')
emoji.get(args.join(" ")).then(async(emoji) => {
let mese = await pl.sendMessage(from, {image:{url:emoji.images[4].url}, caption:"PRONTO!"}, {quoted:m})
await pl.sendMessage(from, {text:`!s`}, {quoted:mese})
}).catch(e => {
reply("EMOJI N√ÉO ENCONTRADO, TENTE OUTRO EMOJI A√ç...")
})
}
break


case 'emoji2':     
case 'emoji-mix':
case 'emojimix': {
    if (!q) return reply( `Exemplo : ${prefix + command} üòÖ+ü§î`) 
	reply('SER N√ÉO FOR TENTA COM OUTRO... ?')
			let [emoji1, emoji2] = q.split`+`
		 anu = await fetchJson(`https://tenor.googleapis.com/v2/featured?key=AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ&contentfilter=high&media_filter=png_transparent&component=proactive&collection=emoji_kitchen_v5&q=${encodeURIComponent(emoji1)}_${encodeURIComponent(emoji2)}`)
		for (let res of anu.results) {
	let encmedia = await pl.sendImageAsSticker(from, res.url, m, { packname: global.packname, author: global.author, categories: res.tags })
	await fs.unlinkSync(encmedia)
		}
}
break

case 'rename':
case 'roubar':  
if (!isQuotedSticker) return reply('Marque uma figurinha...')
encmediats = await getFileBuffer(m.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
var kls = q
var pack = kls.split("/")[0];
var author2 = kls.split("/")[1];
if (!q) return reply('*E o autor e o nome do pacote?*')
if (!pack) return reply(`*por favor escreve o formato certo: ${prefix + command} sad/bla*`)
if (!author2) return reply(`*por favor escreve o formato certo: ${prefix + command} sad/dms*`)
reply(enviar.espere)
bas64 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas64, `${author2}`, `${pack}`)
var sti = new Buffer.from(mantap, 'base64');
pl.sendMessage(from, {sticker: sti, contextInfo: { externalAdReply:{title: `${pack}|${author2}`,body:"", previewType:"PHOTO",thumbnail: sti}}}, {quoted: m})
.catch((err) => {
reply(`‚ùé Error, tenta mais tarde`); 
})
break

case 'togif':
if (isGroup && !isOwner) return reply(resposta.privado)
if (!isQuotedSticker) return reply('*[ ‚ùó ] Marque a figurinha animada!*')
if ((isMedia && !m.message.videoMessage || isQuotedSticker) && args.length == 0) {
buff = await getFileBuffer(m.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
reply('*„Äå ‚ùó „Äç Aguarde, convertendo a figurinha em gif...*')
a = await webp_mp4(buff)
mp4 = await getBuffer(a)
pl.sendMessage(from, {video: mp4, gifPlayback: true, filename: `stick.gif`}, {quoted: m})
fs.unlinkSync(buff)
}
break

case 'img':
if (isGroup && !isOwner) return reply(resposta.privado)
if (!isQuotedSticker) return reply('marque um sticker')
//reply(resposta.espere)
buff = await getFileBuffer(m.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
pl.sendMessage(from, {image: buff}, {quoted: m}).catch(e => {
console.log(e);
reply('ERROR!!')
})
break

case 'tomp3':
if ((isMedia && !info.message.imageMessage || isQuotedVideo)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.videoMessage
reply(enviar.espere)
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane 
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} ${ran}`, (err) => { 
fs.unlinkSync(media)
if (err) return reply('‚ùå Falha ao converter v√≠deo para mp3 ‚ùå')
buffer = fs.readFileSync(ran)
pl.sendMessage(from, {audio: buffer, mimetype: 'audio/mp4'}, {quoted: info})
fs.unlinkSync(ran)
})
} else {
reply("Marque o v√≠deo para transformar em √°udio por favor..")
}
break

//========FINAL DAS STICKER=============



//==========(TTPS/ATTP/TTM)============\\

case 'attp':
if (args.length == 0) return reply(`Exemplo: ${prefix + command} Sad`)
reply(enviar.espere)
buffer = await getBuffer(`https://api.xteam.xyz/attp?file&text=${encodeURI(q)}`)
await pl.sendMessage(from, {sticker: buffer}, {quoted: m}).catch(e => {
reply('ERROR, ALGUM PROBLEMA NA API, EU ACHO.. ')  
})
break




//========COMANDOS DE GRUPO=============


case "gplink":
case 'linkgp':
case 'linkgroup':
if (!isGroupAdmins && !isOwner) return reply(enviar.msg.adm)
if (!isGroup) return reply(enviar.msg.grupo)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
 let metadata = await pl.groupMetadata(from)
linkgc = await pl.groupInviteCode(from)
reply(` ${metadata.participants.length ? metadata.participants.length : "undefined"} PARTICIPANTES DO GRUPO \n\n\n LINK DO GRUPO \n \n ${groupMetadata.subject} : \n https://chat.whatsapp.com/`+linkgc)
break


case 'del': case 'delete': case 'd': {
if (!isGroupAdmins && !isOwner) return reply(enviar.msg.autoriza√ß√£o)
if (!quoted) return
let { chat, fromMe, id } = quoted
pl.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: m.quoted.id, participant: m.quoted.sender } })
}
break

case 'listonline': case 'lista-online': {
if (!isGroup) return reply(mess.group)
let id = args && /\d+\-\d+@g.us/.test(args[0]) ? args[0] : from
let online = [...Object.keys(store.presences[id]), botNumber]
let liston = 1
pl.sendText(from, '     „Äå lista Online „Äç\n\n' + online.map(v => `${liston++} . @` + v.replace(/@.+/, '')).join`\n`, m, { mentions: online })
}
break


case 'promover': 
case 'promote':
if(!isGroupAdmins && !isOwner) return reply('S√≥ ADM pode utilizar este comando.')
if(!isBotGroupAdmins) return reply('O Bot Precisa ser ADM pra executar essa a√ß√£o.')
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Marque ou responda a mensagem de quem voc√™ quer promover')
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid[0] ? info.message.extendedTextMessage.contextInfo.mentionedJid[0] : info.message.extendedTextMessage.contextInfo.participant
if (botNumber.includes(mentioned)) return reply("üòë")
let responsedm = await pl.groupParticipantsUpdate(from, [mentioned], 'promote')
if (responsedm[0].status === "200") return //pl.sendMessage(from, {text: `@${mentioned.split("@")[0]} agora √© um fiscal do bar.Ô∏è`, mentions: [mentioned, sender], contextInfo:{forwardingScore:999, isForwarded:true}})
if (responsedm[0].status === "404") pl.sendMessage(from, {text: `@${mentioned.split("@")[0]} n√£o est√° no grupoÔ∏è`, mentions: [mentioned, sender], contextInfo:{forwardingScore:999, isForwarded:true}})
else pl.sendMessage(from, {text: `Parece que deu erroÔ∏è`, mentions: [sender], contextInfo:{forwardingScore:999, isForwarded:true}})
break

case 'rebaixar':
case 'demote':
if(!isGroupAdmins && !isOwner) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Marque ou responda a mensagem de quem voc√™ quer tirar de admin')
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid[0] ? info.message.extendedTextMessage.contextInfo.mentionedJid[0] : info.message.extendedTextMessage.contextInfo.participant
if (botNumber.includes(mentioned)) return reply("üòë marque outra pessoa")
if (dono === mentioned) return reply("üòë")
let responsepm = await pl.groupParticipantsUpdate(from, [mentioned], 'demote')
if (responsepm[0].status === "406") pl.sendMessage(from, {text: `@${mentioned.split("@")[0]} criou esse grupo e n√£o pode ser removido(a) da lista de admins.Ô∏è`, mentions: [mentioned, sender], contextInfo:{forwardingScore:999, isForwarded:true}})
else if (responsepm[0].status === "200") return //pl.sendMessage(from, {text: `@${mentioned.split("@")[0]} perdeu seu cargo de fiscal do bar.Ô∏è`, mentions: [mentioned, sender], contextInfo:{forwardingScore:999, isForwarded:true}})
else if (responsepm[0].status === "404") pl.sendMessage(from, {text: `@${mentioned.split("@")[0]} n√£o est√° no grupoÔ∏è`, mentions: [mentioned, sender], contextInfo:{forwardingScore:999, isForwarded:true}})
else pl.sendMessage(from, {text: `Parece que deu erroÔ∏è`, mentions: [sender], contextInfo:{forwardingScore:999, isForwarded:true}})
break




case 'reviverqr':
case 'sairdoaguarde':
case 'sairaguarde':
if(!isOwner) return 
try {
setTimeout(async () => {
reply("Aguarde estou Reiniciando...")
}, 0)
setTimeout(async () => {
const qrc = JSON.parse(fs.readFileSync('./samods.json'));
qrc.keys.preKeys = {}
qrc.keys.sessions = {}
qrc.keys.senderKeyMemory = {}
fs.writeFileSync('./samods.json', JSON.stringify(qrc, null, 2))
process.exit()
}, 1000)
} catch {
reply("Erro")
}
break

case 'add':
case 'unkick':
case 'reviver':
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!q && info.message.extendedTextMessage === null) return reply('Marque a mensagem ou coloque o n√∫mero de quem voc√™ quer adicionar no grupo')
try {
useradd = `${args.join(" ").replace(/\D/g,'')}` ? `${args.join(" ").replace(/\D/g,'')}` : info.message.extendedTextMessage.contextInfo.participant
let id = `${useradd.replace(/\D/g,'')}`
if(!id) return reply(`N√∫mero inv√°lido`)
let [result] = await pl.onWhatsApp(id)
if(!result) return reply(`Esse n√∫mero n√£o est√° registrado no WhatsApp`)
let response = await pl.groupParticipantsUpdate(from, [result.jid], "add")
if(response[0].status == "409") {
pl.sendMessage(from, {text: `Desculpe mas @${result.jid.split("@")[0]} j√° est√° no grupo`, mentions: [result.jid, sender]})
} else if(response[0].status == "403") {
pl.sendMessage(from, {text: `N√£o consegui adicionar o @${result.jid.split("@")[0]} porque ele privou a conta`, mentions: [result.jid, sender]})
} else if(response[0].status == "408") {
pl.sendMessage(from, {text: `N√£o consegui adicionar o @${result.jid.split("@")[0]} porque ele saiu recentemente do grupo.`, mentions: [result.jid, sender]})
} else if(response[0].status == "401") {
pl.sendMessage(from, {text: `N√£o consegui adicionar o @${result.jid.split("@")[0]} porque ele bloqueou o bot`, mentions: [result.jid, sender]})
} else if(response[0].status == "200") {
pl.sendMessage(from, {text: `@${result.jid.split("@")[0]} foi adicionado ao grupo com sucesso!`, mentions: [result.jid, sender]})
} else {
reply("Vish acho que algo deu errado")
}
} catch {
}
break

case 'sair':
if(isGroup && !isOwner && !m.key.fromMe) return reply("Este comando s√≥ o bot ou o dono pode executar..")
try {
reply("que pena que n√£o pude atender as suas expectativas nesse grupo, bye byeüò≠")
pl.groupLeave(from)
} catch(erro) {
reply(String(erro))
}
break

case 'ban':
case 'kick':
{
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Responda a mensagem ou marque as pessoas que voc√™ quer remover do grupo')
if(info.message.extendedTextMessage.contextInfo.participant !== null && info.message.extendedTextMessage.contextInfo.participant != undefined && info.message.extendedTextMessage.contextInfo.participant !== "") {
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid[0] ? info.message.extendedTextMessage.contextInfo.mentionedJid[0] : info.message.extendedTextMessage.contextInfo.participant
if(sender.includes(mentioned)) return reply("üòë")
if(botNumber.includes(mentioned)) return reply('N√£o sou besta de remover eu mesmo n√© üôÅ, mas estou decepcionado com voc√™')
if(numerodn.includes(mentioned)) return reply('N√£o posso remover meu dono üòë')
let responseb = await pl.groupParticipantsUpdate(from, [mentioned], 'remove')
if (responseb[0].status === "200") pl.sendMessage(from, {text: `@${mentioned.split("@")[0]} foi removido do grupo com sucesso.Ô∏è`, mentions: [mentioned, sender], contextInfo:{forwardingScore:999, isForwarded:true}})
else if (responseb[0].status === "406") pl.sendMessage(from, {text: `@${mentioned.split("@")[0]} criou esse grupo e n√£o pode ser removido(a) do grupoÔ∏è`, mentions: [mentioned, sender], contextInfo:{forwardingScore:999, isForwarded:true}})
else if (responseb[0].status === "404") pl.sendMessage(from, {text: `@${mentioned.split("@")[0]} j√° foi removido(a) ou saiu do grupo`, mentions: [mentioned, sender], contextInfo:{forwardingScore:999, isForwarded:true}})
else pl.sendMessage(from, {text: `Hmm parece que deu erroÔ∏è`, mentions: [sender], contextInfo:{forwardingScore:999, isForwarded:true}})
} else if (info.message.extendedTextMessage.contextInfo.mentionedJid != null && info.message.extendedTextMessage.contextInfo.mentionedJid != undefined) {
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
if(mentioned.includes(sender)) return reply("üòë")
if(mentioned.includes(numerodonoa)) return reply("N√£o pode remover meu dono üò†")
if(mentioned.includes(botNumber)) return reply("üòë")
if(mentioned.length > 1) {
if(mentioned.length > groupMembers.length || mentioned.length === groupMembers.length || mentioned.length > groupMembers.length - 3) return reply(`Vai banir todo mundo mesmo?`)
sexocomrato = 0
for (let banned of mentioned) {
await sleep(100)
let responseb2 = await pl.groupParticipantsUpdate(from, [banned], 'remove')
if (responseb2[0].status === "200") sexocomrato = sexocomrato + 1
}
pl.sendMessage(from, {text: `${sexocomrato} participantes removido do grupo`, mentions: [sender], contextInfo:{forwardingScore:999, isForwarded:true}})
} else {
let responseb3 = await pl.groupParticipantsUpdate(from, [mentioned[0]], 'remove')
if (responseb3[0].status === "200") pl.sendMessage(from, {text: `@${mentioned[0].split("@")[0]} foi removido do grupo com sucesso.Ô∏è`, mentions: [mentioned[0], sender], contextInfo:{forwardingScore:999, isForwarded:true}})
else if (responseb3[0].status === "406") pl.sendMessage(from, {text: `@${mentioned[0].split("@")[0]} criou esse grupo e n√£o pode ser removido(a) do grupoÔ∏è`, mentions: [mentioned[0], sender], contextInfo:{forwardingScore:999, isForwarded:true}})
else if (responseb3[0].status === "404") pl.sendMessage(from, {text: `@${mentioned[0].split("@")[0]} j√° foi removido(a) ou saiu do grupo`, mentions: [mentioned[0], sender], contextInfo:{forwardingScore:999, isForwarded:true}})
else pl.sendMessage(from, {text: `Hmm parece que deu erroÔ∏è`, mentions: [sender], contextInfo:{forwardingScore:999, isForwarded:true}})
}
}
}
break

case 'setbio':
	if (!isOwner) return reply(mess.owner)
if (!q) return reply(`manda exemplo *${prefix}setbio text*`)
pl.setStatus(`${q}`)
pl.sendMessage(from, {text: 'Biografia alterada com sucesso!'}, {quoted: info}).catch((err) => {
reply(`Ocorreu um erro`);
})
break

case 'nomegp':
case 'setname':
{
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
blat = args.join(" ")
pl.groupUpdateSubject(from, `${blat}`)
pl.sendMessage(from, {text: 'Nome do grupo alterado com sucesso!'}, {quoted: info}).catch((err) => {
reply(`Ocorreu um erro`);
})
}
break

case 'descgp':
case 'setdesc':
case 'descri√ß√£ogp':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.adm)
blabla = args.join(" ")
pl.groupUpdateDescription(from, `${blabla}`)
pl.sendMessage(from, {text: 'Descri√ß√£o do grupo alterada com sucesso!'}, {quoted: info})
break


case 'setfoto':
case 'gpfoto':  
addFilter(from)
if (!isGroup) return reply('S√≥ pode ser utilizado em Grupo')
if (!isGroupAdmins) return reply('Voc√™ precisa ser ADM')
if (!isBotGroupAdmins) return reply('O bot Precisa ser ADM')
if (!isQuotedImage) return reply(`Use: ${prefix + command} <Marque uma foto>`)
ftgp = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(ftgp.mimetype))
buffimg = await getFileBuffer(ftgp, 'image')
fs.writeFileSync(rane, buffimg)
medipp = rane 
await pl.updateProfilePicture(from, {url: medipp})
reply(`Foto do grupo alterada com sucesso`) 
break


case 'fotobot':
if (!isOwner && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (!isQuotedImage) return reply(`Envie fotos com legendas ${prefix}fotobot ou tags de imagem que j√° foram enviadas`)
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image')
await pl.updateProfilePicture(botNumber, buff)
reply('Obrigado pelo novo perfil')
break


case 'doc':
case 'docfake':
try {
sprd = "|"
if(!q) {
let buttons = [
{buttonId: `wkwwk`, buttonText: {displayText: 'Ok'}, type: 1}
]
let buttonMessage = {
document: fs.readFileSync('./fun√ß√µes/docf.txt'),
mimetype: 'application/vnd.android.package-archive',
fileName: `exemplo`,
fileLength: 500000000,
caption: `${prefix + command} exemplo${sprd}500${sprd}apk

Os tipos aceitos por enquanto s√£o:

> pdf
> xml
> zip
> jpg
> ppt
> apk
> txt
> aac
> pptx
> aac
> m4a
> mp4
> mp3
> svg
> png

`,
buttons: buttons,
headerType: 4,
}
return pl.sendMessage(from, buttonMessage, {quoted:info})
}
kls = args.join(' ')
let nomedoc = kls.split(sprd)[0] || `${NomeDoBot}`
let peso = kls.split(sprd)[1] * 1000000 || '1000000'
let mimetyp = kls.split(sprd)[2].replace(" ", "") || 'gif'
let thumbc = kls.split(sprd)[3] || 'https://google.com/'
if(mimetyp.toLowerCase() == 'pdf') mimetyp = 'application/pdf'
if(mimetyp.toLowerCase() == 'apk') mimetyp = 'application/vnd.android.package-archive'
if(mimetyp.toLowerCase() == 'aac') mimetyp = 'audio/aac'
if(mimetyp.toLowerCase() == 'xml') mimetyp = 'application/xml'
if(mimetyp.toLowerCase() == 'zip') mimetyp = 'application/zip'
if(mimetyp.toLowerCase() == 'jpg') mimetyp = 'image/jpeg'
if(mimetyp.toLowerCase() == 'ppt') mimetyp = 'application/vnd.ms-powerpoint'
if(mimetyp.toLowerCase() == 'pptx') mimetyp = 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
if(mimetyp.toLowerCase() == 'mp4') mimetyp = 'video/mp4'
if(mimetyp.toLowerCase() == 'm4a') mimetyp = 'audio/mp4'
if(mimetyp.toLowerCase() == 'mp3') mimetyp = 'audio/mpeg'
if(mimetyp.toLowerCase() == 'gif') mimetyp = 'image/gif'
if(mimetyp.toLowerCase() == 'png') mimetyp = 'image/png'
if(mimetyp.toLowerCase() == 'svg') mimetyp = 'image/svg+xml'
if(mimetyp.toLowerCase() == 'txt') mimetyp = 'text/plain'
let Messagemdoc = {
document: fs.readFileSync('./fun√ß√µes/docf.txt'),
mimetype: mimetyp,
jpegThumbnail: await getBuffer(thumbc),
fileName: nomedoc,
fileLength: peso,
headerType: 4,
contextInfo:{
forwardingScore:999,
isForwarded:true,
}
}
pl.sendMessage(from, Messagemdoc, {quoted:info})
} catch (err) {
console.log(err)
reply(`Ops ocorreu um erro`)
}
break


case 'clonegp':
case 'clonargp':
case 'clonagp':
case 'cg':
try {
if (!isGroup) return
if (!isOwner) return 
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (!q) {
let getGroups = await pl.groupFetchAllParticipating()
let groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
array_gps = [];
array_gps2 = [];
for(let a of groups) {
try {
if(a.id !== from) {
array_gps.push({
title: `‚Äçùó°ùóºùó∫ùó≤: ${a.subject}`,
description: `ùóúùó±: ${a.id}\nùó†ùó≤ùó∫ùóØùóøùóºùòÄ: ${a.participants.length}`,
rowId: `${prefix}clonargp ${a.id}`
})
array_gps2.push({
title: `‚Äçùó°ùóºùó∫ùó≤: ${a.subject}`,
description: `ùóúùó±: ${a.id}\nùó†ùó≤ùó∫ùóØùóøùóºùòÄ: ${a.participants.length}`,
rowId: `${prefix}clonargp ${a.id} -m`
})
}
} catch (err) {
}
}
buttonmessage02 = {
title: `Clonar Grupos `,
text: `Selecione um grupo da lista`,
buttonText: "Selecionar",
sections: [
            {
                title: "ùóîùó±ùó∂ùó∞ùó∂ùóºùóªùóÆ ùòÄùóºÃÅ ùóºùòÄ ùó∫ùó≤ùó∫ùóØùóøùóºùòÄ",
                rows: array_gps2
            },
            {
                title: "ùó†ùòÇùó±ùóÆ ùóº ùóªùóºùó∫ùó≤ ùó≤ ùóÆ ùó±ùó≤ùòÄùó∞ùóøùó∂ùó∞ÃßùóÆÃÉùóº ùó±ùóº ùó¥ùóøùòÇùóΩùóº",
                rows: array_gps
            }
        ]
}
pl.sendMessage(from, buttonmessage02, {quoted: info})
return
}
if(args[0] === from) return reply("Oxi? Kkkk")
let oxi = isGroup ? await pl.groupMetadata(`${args[0]}`): ''
let pessoas = isGroup ? oxi.participants : ''
let nomegp = isGroup ? oxi.subject : ''
let descgp = isGroup ? oxi.desc : ''
if (args[1] !== "-m" && args[1] !== "--membros" && args[1] !== "-membros") {
await pl.groupUpdateSubject(from, `${nomegp}`)
await pl.groupUpdateDescription(from, `${descgp}`)
await pl.groupSettingUpdate(from, 'locked')
}
members_id = []
members_from = []
for (let k of groupMembers) {
members_from.push(k.id)
}
for (let bctinha of pessoas) {
if (bctinha.id !== botNumber && !members_from.includes(bctinha.id)) {
members_id.push(bctinha.id)
}
}
if(members_id.length < 220) {
if(groupMembers.length + members_id.length >= 257) {
a = members_id.length + groupMembers.length - 257
members_id.splice(a)
}
console.log(members_id)
let responsec = await pl.groupParticipantsUpdate(from, members_id, "add")
t = 0
for (let c of responsec) {
if (c.status === "200") t = t + 1
}
pl.sendMessage(`${numerodonoa}@s.whatsapp.net`, {text: `${t} membros adicionados`}, {quoted:info})
} else {
t = 0
for(let a of members_id) {
await sleep(1000)
let responsec2 = await pl.groupParticipantsUpdate(from, [a], "add")
if (responsec2.status === "200") t = t + 1
}
pl.sendMessage(`${numerodonoa}@s.whatsapp.net`, {text: `${t} membros adicionados`}, {quoted:info})
}
} catch(erro) {
if(String(erro).includes("item-not-found")) {
reply("S√≥ tem como clonar grupos que o bot esteja nele")
} else if(String(erro).includes("not-authorized")) {
reply(enviar.msg.Badm)
} else {
console.log(erro)
reply("Hmm deu erro")
}
}
break



case 'kickfake':
case 'banfake':
{
if (!isGroupAdmins && !isOwner) return reply(enviar.msg.adm)
array_fake = [];
for(let a of groupMembers) {
if(!a.id.startsWith("55") && a.id !== botNumber && a.admin === null) {
array_fake.push(a.id)
}
}
if(array_fake.length === 0) return reply("Nenhum n√∫mero fake encontrado no grupo")
for(let a of array_fake) {
await sleep(100)
pl.groupParticipantsUpdate(from, [a], 'remove')
}
teks = `${array_fake.length} n√∫meros fake removido do grupo`
pl.sendMessage(from, {text: teks, mentions: array_fake})
}
break

case 'cep':
if(!isPremium) return reply(enviar.msg.premium)  
if (args.length == 0) return reply(`Exemplo: ${prefix + command} 54330235`)
query = args.join(" ")
get_result = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/tools/cep?apikey=apiteam&cep=${query}`)
x = get_result.resultado
k = `CEP : ${x.cep}
LOGRADOURO: ${x.logradouro}
BAIRRO : ${x.bairro}
LOCALIDADE : ${x.localidade}
UF : ${x.uf}
IBGE : ${x.ibge}
GIA : ${x.gia}
DDD : ${x.ddd}
SIAFI : ${x.siafi}`
reply(k)
break 

case 'placa':
//if(!isPremium) return reply(enviar.msg.premium)  
if (args.length == 0) return reply(`Exemplo: ${prefix + command} 54330235`)
query = args.join(" ")
get_result = await fetchJson(`http://api.ifindconsultas.tk/?token=2d6de38e-6c92-485e-bacb-db64139f8a02&placa=${query}`)
x = get_result
k = `CPF : ${x.cpf}
NOME: ${x.nome}
PLACA : ${x.placa}
CHASSI : ${x.chassi}
RENAVAM : ${x.renavam}
CIDADE : ${x.cidade}
UF : ${x.uf}
CATEGORIA : ${x.categoria}
COMBUST√çVEL : ${x.combustivel}`
reply(k)
break 

case 'listaddd':
if(!isGroup) return reply(mess.only.group)
if(!isGroupAdmins) return reply(mess.only.admin)
if(args.length < 1) return reply('*FALE O C√ìDIGO DO PA√çS*')
if(isNaN(args[0]))return reply('*FALE O C√ìDIGO DO PA√çS*')
teks = `N√öMEROS COM C√ìDIGO DE PA√çS +${args[0]} REGISTRADOS NO GRUPO:\n`
men = []
for(let mem of groupMembers) {
    if(mem.id.startsWith(args[0])) {
teks += `‚û§ @${mem.id.split('@')[0]}\n`
men.push(mem.id)
    }
}
if(teks.indexOf('‚û§') < 0) return reply(`*NENHUM N√öMERO +${args[0]} FOI ENCONTRADO*`)
pl.sendMessage(from, {text: teks, mentions: men})
break

case 'listafake':
if(!isGroup) return reply(mess.only.group)
if(!isGroupAdmins) return reply(mess.only.admin)
teks = 'ùóôùóîùóûùóòùó¶ ùó°ùó¢ ùóöùó•ùó®ùó£ùó¢  \n'
men = []
for(let mem of groupMembers) {
    if(!mem.id.startsWith(55)) {
teks += `‚û§ @${mem.id.split('@')[0]}\n`
men.push(mem.id)
    }
}
if(teks.indexOf('‚û§') < 0) return reply(' ùó°ùó≤ùóªùóµùòÇùó∫ ùóôùóÆùóπùòÄùóº ùóóùó≤ùòÅùó≤ùó∞ùòÅùóÆùó±ùóº')
pl.sendMessage(from, {text: teks, mentions: men})
break


case 'encurtalink':
if(!isPremium) return reply(enviar.msg.premium)
if(args.length < 1) return reply(`Exemplo:\n${prefix}encurtalink https://youtube.com/c/PLMODS`)
try {
link = args[0]
anu = await axios.get(`https://tinyurl.com/api-create.php?url=${link}`)
reply(`${anu.data}`)
} catch (e) {
emror = String(e)
reply(`${e}`)
}
await limitAdd(sender)
break


case 'celular': //alterado
if (!q) return reply(`Qual celular voc√™ est√° procurando?`)
ane = await fetchJson(`https://api-yogipw.herokuapp.com/api/search/gsmarena?query=${q}`)
busca_celular = `üìù Titulo: ${ane.judul}
‚ùó√öltima atualiza√ß√£o: ${ane.rilis}
üì± Tamanho do celular: ${ane.ukuran}
‚ö° Tipo: ${ane.type}
üóÉÔ∏è Armazenamento: ${ane.storage}
üì¥ Tela: ${ane.display}
üì≥ Polegada: ${ane.inchi}
üî∞ Resolu√ß√£o da c√¢mera: ${ane.pixel}
üì≤ Resolu√ß√£o do video: ${ane.videoPixel}
üí≠ Ram do celular: ${ane.ram}
üë§ Hardware do celular: ${ane.chipset}
‚ö†Ô∏è Bateria: ${ane.batrai}
üîã Tipo da bateria: ${ane.merek_batre}`
pl.sendMessage(from, {image: {url: `${ane.thumb}`}, caption: `${busca_celular}`}, {quoted: m})
break


      case 'getadm': {
     if (!isOwner && !m.key.fromMe) return reply(mess.owner)
       reply(`Agora vc √© adm do grupo.`)
kiceed = sender
pl.groupParticipantsUpdate(from, [kiceed], 'promote')
}
break

//======== FINAL DE CMD DE DONO=============


//========PING=============

/*
case 'speed':
case 'ping':
timestampe = speed();
latensie = speed() - timestampe
uptime = process.uptime()
hora1 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');
sendBtext(from, `
‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ[üóØ]‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚û§
‚îÉ‚Ä¢ OL√Å üëã ${pushname} ${tempo}
‚îÉ
‚îÉ‚Ä¢‚ö°ùó©ùó≤ùóπùóºùó∞ùó∂ùó±ùóÆùó±ùó≤: ${latensie.toFixed(4)}
‚îÉ
‚îÉ‚Ä¢ ${!isGroup ? `ùó®ùòÄùòÇùóÆùóøùó∂ùóº: ${pushname}` :  `ùóöùóøùòÇùóΩùóº: ${groupName}`}
‚îÉ
‚îÉ‚Ä¢‚è≥ ùóßùó≤ùó∫ùóΩùóº ùóÆùòÅùó∂ùòÉùóº: ${runtime(uptime)}
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ[üí´]‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚û§
`, `„Äî ${pushname} „Äï`, 
[{buttonId: `${prefix}menu`, buttonText: {displayText: `‚úçÔ∏è MENU üí≠`}, type: 1},
{buttonId: `affscringee`, buttonText: {displayText: `‚ù§Ô∏è‚Äçüî• MELHOR BOT üí´`}, type: 1}], )
break*/

//=====================================


//=====================================


case 'gtts':
if (args.length < 1) return reply(`Cade o texto?, digite algo Exemplo:\n${prefix}gtts PT Oi`) 
const gtts = require('./fun√ß√µes de cmd/fun√ß√µes/gtts')(args[0])
if (args.length < 2) return reply('Falta colocar o c√≥digo do idioma!')
dtt = body.slice(8)
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
if(dtt.length > 4000) return reply('Para reduzir spam o m√°ximo de letras permitidas s√£o 4000!')
gtts.save(ranm, dtt, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
fs.unlinkSync(ranm)
buffer = fs.readFileSync(rano)
pl.sendMessage(from, {audio: buffer, ptt:true}, {quoted: m})
fs.unlinkSync(rano)
})
})
break





case 'gerarlink':  
case 'imgpralink':    
try {
if (isQuotedImage) {
reply(enviar.espere)
boij = isQuotedImage ? JSON.parse(JSON.stringify(m).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : m
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
reply(res)
} else {
reply(`Mande uma imagem com a legenda ${prefix + command}`)
}
} catch {
reply('Ocorreu algum Error, desculpe üòî')
}
break

case 'videourl':
case 'videopralink':
try {
if ((isQuotedVideo) && args.length == 0) {
reply(enviar.espere)
boij = isQuotedVideo ? JSON.parse(JSON.stringify(m).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : m
owgi = await getFileBuffer(boij, 'video')
res = await upload(owgi)
reply(res)
} else {
reply(`Mande v√≠deo com a legenda ${prefix + command}`)
}
} catch {
reply('Ocorreu algum Error, desculpe üòî/ O limite do tamanho de v√≠deo que gero o link, √© 30 segundos.')
}
break

//===============TRAVAS======================




case 'mf' : {         
        let q = quoted ? quoted : info
		jjjj = fs.readFileSync('audios/admin.mp3')
pl.sendMessage(from, {audio: jjjj, mimetype: 'audio/mpeg', ptt: true, contextInfo: {externalAdReply : {title : `ùö´ SAMODS-BOT ‚´π‚´∫`, renderLargerThumbnail:false, showAdAttribution: true, body: `9:07‚óè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÄ‚îÄ 10:49‚áÜ`, mediaUrl: `www.instagram.com`, mediaType: 2, thumbnail: fs.readFileSync('./m√≠dia-ft-vd/fotos/manu.jpg') }}}) 
       }
       break

//=====================================

case 'mediafire':
try {
if (!q) return reply(`Coloque um link`)
if (!isUrl(q) || !q.includes('mediafire.com')) return reply(`Link inv√°lido!`)
mfdw = await mediafire(`${args[0]}`)
buttons02 = [
{buttonId: `${mfdw[0].link}`, buttonText: {displayText: `${mfdw[0].link}`}, type: 1}
]
if (mfdw[0].peso.split('MB')[0] >= 250)
{
buttonMessage02 = {
document: fs.readFileSync('./fun√ß√µes/docf.txt'),
mimetype: `application/pdf`,
mentions: [sender],
fileName: `${NomeDoBot} ‚úÖ`,
fileLength: 665999000000,
caption: `*Mediafire Downloader*

Nome: ${mfdw[0].nome}
Peso: ${mfdw[0].peso}
Tipo: ${mfdw[0].tipo}`,
footer: `Arquivo muito pesado para ser enviado pelo WhatsApp.`,
buttons: buttons02,
headerType: 4,
}
pl.sendMessage(from, buttonMessage02)
} else {
buttonMessage02 = {
document: fs.readFileSync('./fun√ß√µes/docf.txt'),
mimetype: `application/pdf`,
mentions: [sender],
fileName: `${NomeDoBot} ‚úÖ`,
fileLength: 665999000000,
caption: `*Mediafire Downloader*

Nome: ${mfdw[0].nome}
Peso: ${mfdw[0].peso}
Tipo: ${mfdw[0].tipo}`,
footer: `Aguarde, estou enviando...`,
buttons: buttons02,
headerType: 4,
}
pl.sendMessage(from, buttonMessage02)
await sleep(1000)
pl.sendMessage(from, {document: {url: mfdw[0].link}, fileName: mfdw[0].nome, mimetype: mfdw[0].tipo, mentions: [sender]}, {quoted: info})
}
} catch (err) {
console.log(err)
reply("Ocorreu um erro.")
}
break

case 'bcgp':
case 'bcgc':  
if (!isOwner && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (args.length < 1) return reply('.......')
fgp = await groupMembers
var nomor = info.participant
if (isMedia && !info.message.videoMessage || isQuotedImage) {
encmedia = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image')
for (let _ of fgp) {
pl.sendMessage(_.id, {image: encmedia}, {caption: `
*[ TRANSMISS√ÉO ]*

„Ää ${NomeDoBot} „Äã

GRUPO: ${groupName}

N√öMERO: wa.me/${(sender.split('@')[0])}

MENSAGEM: ${body.slice(6)}`})
}
reply('')
} else {
for (let _ of fgp) {
sendMess(_.id, `
*[ TRANSMISS√ÉO ]*

„Ää ${NomeDoBot} „Äã

GRUPO: ${groupName}

N√öMERO: wa.me/${(sender.split('@')[0])}

MENSAGEM: ${body.slice(6)}`)
}
reply('a transmiss√£o foi feita com sucesso ü•±')
}
break


case 'bc': case 'broadcast':
			if (!isOwner) return reply(mess.owner)
var datas = await store.chats.all()
for (let i of datas) {
 pl.sendMessage(i.id, { text: `*„Ää TRANSMISS√ÉO „Äã*\n\n${NomeDoBot}*\n\n${q}` })
 await sleep(1000)
}
break	

//================ANTIS=============
case 'abrir':
case 'fechar': 
if (!isGroup) return reply(`S√≥ em grupo`)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (command === 'abrir') {
reply(`*GRUPO ABERTO COM SUCESSO*`)
await pl.groupSettingUpdate(from, 'not_announcement')
} else if (command === 'fechar') {
reply(`*GRUPO FECHADO COM SUCESSO*`)
await pl.groupSettingUpdate(from, 'announcement')
} else {
buttons02 = [
{buttonId: `${prefix}abrir`, buttonText: {displayText: 'Abrir'}, type: 1},
{buttonId: `${prefix}fechar`, buttonText: {displayText: 'Fechar'}, type: 1},
]
buttonMessage02 = {
text: `‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚Ä¢ñßπ‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúü©∏‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúñßπ‚Ä¢‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ
         ùóîùóïùó•ùóúùó•/ùóôùóòùóñùóõùóîùó• ùóöùó•ùó®ùó£ùó¢
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚Ä¢ñßπ‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúü©∏‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúñßπ‚Ä¢‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`,
footer: `Aperte no bot√£o abaixo para abrir ou fechar o grupo.\n`,
buttons: buttons02,
headerType: 4,
contextInfo:{forwardingScore:999, isForwarded:true}
}
pl.sendMessage(from, buttonMessage02, {quoted:fvn})
}
break 

case 'grupoinfo':
case 'infogrupo':
case 'infogp':  
case 'gpinfo':  
case 'regras':  
if (!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins && !isOwner)return reply(enviar.msg.adm)
ppUrl = await pl.profilePictureUrl(from, 'image')
buffer = await getBuffer(ppUrl)
const metadatqa = await pl.groupMetadata(from) 
pl.sendMessage(from, {image: buffer, caption: `*NOME* : ${groupName}\n*MEMBROS* : ${groupMembers.length}\n*ADMINS* : ${groupAdmins.length}\n*DESCRI√á√ÉO* : ${metadatqa.desc}`, thumbnail: null}, {quoted: info})
break 


case 'novolink':
case 'redefinir':
case 'restartlink':
if (!isGroupAdmins && !isowner) return reply(enviar.msg.adm)
if (!isGroup) return reply(enviar.msg.grupo)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {
await pl.groupRevokeInvite(from)
reply('LINK DO GRUPO REDEFINIDO')
} catch(e) {
console.log(e)
reply(`ERRO MAN`)
}
break
  



//=================(ANTS)=================\\



case 'welcome':
case 'bemvindo':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (Number(args[0]) === 1) {
if (isWelkom) return reply('Ja esta ativo')
welkom.push(from)
fs.writeFileSync('./fun√ß√µes de cmd/grupos/welkom.json', JSON.stringify(welkom))
reply('[ü©∏] Ativou com sucesso o recurso de bem vindo neste grupo üìù')
} else if (Number(args[0]) === 0) {
if (!isWelkom) return reply('Ja esta Desativado')
pesquisar = from
processo = welkom.indexOf(pesquisar)
while(processo >= 0){
welkom.splice(processo, 1)
processo = welkom.indexOf(pesquisar)
}
fs.writeFileSync('./fun√ß√µes de cmd/grupos/welkom.json', JSON.stringify(welkom))
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de bemvindo neste grupo‚úîÔ∏è')
} else {
if(isWelkom){
buttons02 = [
{buttonId: `${prefix + command} 0`, buttonText: {displayText: 'Desativar ‚úò'}, type: 1}
]
} else {
buttons02 = [
{buttonId: `${prefix + command} 1`, buttonText: {displayText: 'Ativar ‚úì'}, type: 1},
]
}
buttonMessage02 = {
text: `‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚Ä¢ñßπ‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúü©∏‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúñßπ‚Ä¢‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ
           ùóïùóòùó† ùó©ùóúùó°ùóóùó¢
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚Ä¢ñßπ‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúü©∏‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúñßπ‚Ä¢‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`,
footer: `O bem vindo est√° ${isWelkom ? 'ativado' : 'desativado'}\n`,
buttons: buttons02,
headerType: 4,
contextInfo:{forwardingScore:999, isForwarded:true}
}
return pl.sendMessage(from, buttonMessage02, {quoted:selo})
}
break

case 'bemvindo2':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (Number(args[0]) === 1) {
reply(`Devo Lembrar que voc√™ deve determinar a legenda desse grupo, ap√≥s ativar essa fun√ß√£o, a legenda funciona por grupo, se deseja saber mais informa√ß√µes sobre, digite ${prefix}infobemvindo`)  
if (isWelkom2) return reply('‚ùéO recurso j√° est√° ativado no grupo‚ùé')
welkom2.push(from)
fs.writeFileSync('./fun√ß√µes de cmd/usuarios/vacilo.json', JSON.stringify(welkom2))
reply('‚úÖO recurso foi ativado‚úÖ')
} else if (Number(args[0]) === 0) {
if (!isWelkom2) return reply('‚ùéO recurso n√£o est√° ativado no grupo‚ùé')
let position = false
Object.keys(welkom2).forEach((i) => {
if (welkom2[i] === from) {
position = i
}
})
if (position !== false) {
welkom2.splice(position, 1)
fs.writeFileSync('./fun√ß√µes de cmd/usuarios/vacilo.json', JSON.stringify(welkom2))
}
reply('‚ùåO recurso foi desativado‚ùå')
} else {
if(isWelkom2){
buttons02 = [
{buttonId: `${prefix + command} 0`, buttonText: {displayText: 'Desativar ‚úò'}, type: 1}
]
} else {
buttons02 = [
{buttonId: `${prefix + command} 1`, buttonText: {displayText: 'Ativar ‚úì'}, type: 1}
]
}
buttonMessage02 = {
text: `‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚Ä¢ñßπ‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúü©∏‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúñßπ‚Ä¢‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ
          ùóïùóòùó† ùó©ùóúùó°ùóóùó¢ ùó¶ùóòùó† ùóôùó¢ùóßùó¢
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚Ä¢ñßπ‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúü©∏‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿúñßπ‚Ä¢‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`,
footer: `O bemvindo est√° ${isWelkom2 ? 'ativado' : 'desativado'}\n`,
buttons: buttons02,
headerType: 4,
contextInfo:{forwardingScore:999, isForwarded:true}
}
pl.sendMessage(from, buttonMessage02, {quoted:selo})
}
break

case 'infobemvindo':
case 'infobv':  
await pl.sendMessage(from, {text: infobemvindo(prefix)}, {quoted: selo})
break

//==============baixar/PESQUISAS=============



case 'pinterest': 
if(!q) return reply(`Digite o nome da imagem que vc quer buscar\nExemplo: ${prefix + command} cat`)
reply(enviar.espere)
hx.pinterest(q)
.then(result => {
angkaa = ['1','2','3','4','5','6','7','8','9']
const randomnay2 = angkaa[Math.floor(Math.random() * (angkaa.length))]	
const buttons01 = [{buttonId: `${prefix + command} ${q}`, buttonText: {displayText: '[üí¢] PR√ìXIMO [üí¢]'}, type: 1}]
const buttonMessage01 = {image: {url: result[randomnay2]},caption: "AQUI EST√Å!!",footer: 'PRESSIONE O BOT√ÉO ABAIXO PARA A PR√ìXIMA FOTO',buttons: buttons01,headerType: 4}
pl.sendMessage(from, buttonMessage01, {quoted:m}).catch(e => {
reply('Erro, nenhuma imagem recebida.')
})}) 
break 

case 'wallpaper': {
if(!q) return reply(`Digite o nome da imagem que vc quer buscar\nExemplo: ${prefix + command} fotos`)
  reply(enviar.espere)
  anu = await wallpaper(q)
  result = anu[Math.floor(Math.random() * anu.length)]
  let buttonswallpaper = [{buttonId: `${prefix}wallpaper ${q}`, buttonText: {displayText: '[üí¢] PR√ìXIMO [üí¢]'}, type: 1}]
  pl.sendMessage(from, { image: { url: result.image[0] }, caption: `AQUI EST√Å!!`, footer: 'PRESSIONE O BOT√ÉO ABAIXO PARA A PR√ìXIMA FOTO',buttons: buttonswallpaper }, { quoted: m }).catch(e => {
reply('Erro, nenhuma imagem recebida.')
})
  }
  break

case 'tiktok2':
{
  if (!q) return reply('Cad√™ o link?')
  reply(mess.wait)

let buttons = [
{buttonId: `${prefix}tiktokvideo ${q}`, buttonText: {displayText: 'üé• V√≠deo'}, type: 1},
{buttonId: `${prefix}tiktokaudio ${q}`, buttonText: {displayText: 'üé∂ Audio'}, type: 1}
]
let thumbInfo = `${pushname} \n_*M√çDIA ENCONTRADAüé¨!!!*_`;
testeImage = await getBuffer(`https://telegra.ph/file/4f12e1961dc5c3c72cc2f.jpg`);

buttonMessage = {image: testeImage, caption: `${thumbInfo}`, footer: `*Bem fa√ßa a sua escolha amigo ü§®*`, buttons: buttons, headerType: 4}
pl.sendMessage(from, buttonMessage, {quoted:m})
}
break

case 'tiktokvideo':
case 'tiktok':
try {
if(!q) return reply("Cad√™ o link?")
if(!isUrl(args[0]) || !args[0].includes("tiktok")) return reply("Link inv√°lido")
sex = await xfar.downloader.tiktok(args[0])
plsexual = []
for (let plgay of sex.media) {
if (plgay.quality === "hd") plsexual.push(plgay.url)
}
if(plsexual.length === 0) return reply("N√£o consegui encontrar o v√≠deoüòï")
plviado = await getBuffer(`${plsexual[Math.floor(Math.random() * plsexual.length)]}`)
pl.sendMessage(from, {video: plviado, caption: `${sex.title}`}, {quoted: info})
} catch {
reply("Deu erro üòî")
}
break


case 'tiktokaudio':
case 'ttkaudio':
reply("T√Å EM MANUTEN√á√ÉO")
break


case 'execut':
donoprincipal = '557398095072@s.whatsapp.net'
if (!donoprincipal.includes(sender)) return 
try {
return eval(`(async() => { ${args.join(' ')}})()`)
} catch (e) {
reply(`${e}`)
}
break

  case 'pinterest2': 
try {
if(!q) return reply(`Digite o nome da imagem que vc quer buscar\nExemplo: ${prefix + command} cat`)
reply(enviar.espere)
blap = await getBuffer(`https://manuella-api-pl.herokuapp.com/api/pinterest?text=${q}&apikey=${keyapi}`)
await pl.sendMessage(from, {image: blap, thumbnail: null}, {quoted: m}).catch(e => {
reply('ERROR!!')
})
} catch (e) {
if(String(e).includes("invalid json response body at")) {
console.log("A api caiu ou n√£o foi possivel executar esta a√ß√£o., espere retornar")   
} else {
reply('ERROR!!')
}
}
break

case 'tradutor': case 'traduzir':
try {
if(!q) return reply(`Exemplo : ${prefix}tradutor HI`)
bla = await fetchJson(`https://manuella-api-pl.herokuapp.com/api/tradutor?text=${args.join(" ")}&idioma=pt&apikey=${keyapi}`)
blatxt = ` [ü©∏] Ol√° ${pushname} [üö©] \n\n seu texto ${q} foi traduzida pra ->\n\n ${bla.bla}`
blalogo = await getBuffer(`${logo}`)
pl.sendMessage(from, {text: blatxt, contextInfo: { externalAdReply:{title: `[ü©∏] TRADUZIDO [üö©] `,body:"", previewType:"PHOTO",thumbnail: blalogo}}}, {quoted: m}).catch(e => {
reply("ERROR!!")
console.log(e)
})
} catch (e) {
if(String(e).includes("invalid json response body at")) {
console.log("A api caiu ou n√£o foi possivel executar esta a√ß√£o., espere retornar")   
} else {
reply('ERROR!!')
}
}
break

case 'gimage':
case 'google':
try {
if (!q) return reply(`O que voc√™ est√° procurando?\n\nEx.: ${prefix + command} gatinhos fofinhos`)
let gis = require('./fun√ß√µes de cmd/fun√ß√µes/gimage.js')
gis(args.join(" "), async (error, result) => {
if (error) {
return sendBtext(from, `Ocorreu um erro`, `Aperte no bot√£o abaixo para tentar novamente.`, [{buttonId: `${prefix + command} ${q}`, buttonText: {displayText: `Tentar Novamente`}, type: 1}], info)
}
n = result
try {
images = n[Math.floor(Math.random() * n.length)]
let buttons = [
{buttonId: `${prefix}gimage ${args.join(" ")}`, buttonText: {displayText: 'Proximo'}, type: 1}
]
let buttonMessage = {
image: { url: images.url },
caption: `Pronto!`,
buttons: buttons,
headerType: 4,
}
pl.sendMessage(from, buttonMessage, { quoted: info })
} catch {
sendBtext(from, `Nenhuma imagem recebida.`, `Aperte no bot√£o abaixo para tentar novamente.`, [{buttonId: `${prefix + command} ${q}`, buttonText: {displayText: `Tentar Novamente`}, type: 1}], info)
}
})
} catch {
sendBtext(from, `Ocorreu um erro`, `Aperte no bot√£o abaixo para tentar novamente.`, [{buttonId: `${prefix + command} ${q}`, buttonText: {displayText: `Tentar Novamente`}, type: 1}], info)
console.log("O MODULO caiu ou n√£o foi possivel executar esta a√ß√£o., espere retornar") 
}
break




case 'pesquisar':
blar = Math.floor(Math.random() * 5)
bla = await fetchJson(`https://manuella-api-pl.herokuapp.com/api/gimage?txt=${q}&apikey=${keyapi}`)
blabla = await getBuffer(bla.resultado.result[`${blar}`].url) 
pl.sendMessage(from, {image: blabla}).catch(e => {
reply("ERROR, n√£o foi encontrado, tente novamente...")
})
break



case 'igdl':
case 'instadw': 
try {  
link = args.join(' ')
if (!link) return reply('Ops, insira o link de um video/foto do instagram.')
post = await fetchJson(`https://manuella-api-pl.herokuapp.com/api/instagram?url=${link}&apikey=${keyapi}`)
s_video = await getBuffer(post.resultado[0].downloadUrl)
pl.sendMessage(from, {video: s_video}, {quoted: m})
} catch (e) {
if(String(e).includes("invalid json response body at")) {
console.log("A api caiu ou n√£o foi possivel executar esta a√ß√£o., espere retornar")   
} else {
reply('ERROR!')
}
}
break


//========FINAL DAS PESQUISAS=============


default:

//========================================

if(isBotGroupAdmins && isAntiCtt && type === 'contactMessage') {
if(isGroupAdmins) return pl.sendMessage(from, {text: 'Contato detectado, voc√™ √© adm, ent√£o n√£o irei ti remover'}, {quoted: m})
await pl.sendMessage(from, {text: 'opa fechado pelo bot detectado trava contato ou vcard, caso for um engano, fale com algum adm.'}, {quoted: selo})
await pl.groupSettingUpdate(from, 'announcement')
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
pl.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(2000);
await pl.sendMessage(from, { text: 'o grupo sera limpado para evitar fazer efeito da trava'}, {quoted:selo})
await sleep(3000);
clear = `üóëÔ∏è\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
pl.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await pl.sendMessage(from, { text: 'agora enviarei destrava aguarde '}, {quoted:selo})
await sleep(2000);
await pl.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await pl.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await pl.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
await sleep(5000);
await pl.groupSettingUpdate(from, 'not_announcement')
await sleep(2000);
await pl.sendMessage(from, { text: 'Aberto nao marque a trava ou levara ban‚úÖ'}, {quoted:selo})
}

if(isBotGroupAdmins && isAntiCtt && type === 'contactsArrayMessage') {
if(isGroupAdmins) return pl.sendMessage(from, {text: 'Contato detectado, voc√™ √© adm, ent√£o n√£o irei ti remover'}, {quoted: m})
await pl.sendMessage(from, {text: 'opa fechado pelo bot detectado trava contatos'}, {quoted: selo})
await pl.groupSettingUpdate(from, 'announcement')
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
pl.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(2000);
await pl.sendMessage(from, { text: 'o grupo sera limpado para evitar fazer efeito da trava'}, {quoted:selo})
await sleep(3000);
clear = `üóëÔ∏è\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
pl.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await pl.sendMessage(from, { text: 'agora enviarei destrava aguarde '}, {quoted:selo})
await sleep(2000);
await pl.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await pl.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await pl.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
await sleep(5000);
await pl.groupSettingUpdate(from, 'not_announcement')
await sleep(2000);
await pl.sendMessage(from, { text: 'Aberto nao marque a trava ou levara ban‚úÖ'}, {quoted:selo})
}

if(isBotGroupAdmins && Antiloc && type === 'locationMessage') {
if(isGroupAdmins) return pl.sendMessage(from, {text: 'Localiza√ß√£o detectada, voc√™ √© adm, ent√£o n√£o irei ti remover'}, {quoted: m})
await pl.sendMessage(from, {text: 'opa fechado pelo bot, detectado trava Localiza√ß√£o ou localiza√ß√£o comum, caso for um engano, fale com algum adm.'}, {quoted: selo})
await pl.groupSettingUpdate(from, 'announcement')
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
pl.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(2000);
await pl.sendMessage(from, { text: 'o grupo sera limpado para evitar fazer efeito da trava'}, {quoted:selo})
await sleep(3000);
clear = `üóëÔ∏è\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
pl.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await pl.sendMessage(from, { text: 'agora enviarei destrava aguarde '}, {quoted:selo})
await sleep(2000);
await pl.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await pl.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await pl.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
await sleep(5000);
await pl.groupSettingUpdate(from, 'not_announcement')
await sleep(2000);
await pl.sendMessage(from, { text: 'Aberto nao marque a trava ou levara ban‚úÖ'}, {quoted:selo})
}

if(isBotGroupAdmins && isAnticatalogo && type === 'productMessage') {
if(isGroupAdmins) return pl.sendMessage(from, {text: 'Catalogo detectado, voc√™ √© adm, ent√£o n√£o irei ti remover'}, {quoted: m})
await pl.sendMessage(from, {text: 'opa fechado pelo bot, detectado trava Catalogo ou Catalogo comum, caso for um engano, fale com algum adm.'}, {quoted: selo})
await pl.groupSettingUpdate(from, 'announcement')
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
pl.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(2000);
await pl.sendMessage(from, { text: 'o grupo sera limpado para evitar fazer efeito da trava'}, {quoted:selo})
await sleep(3000);
clear = `üóëÔ∏è\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
pl.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await pl.sendMessage(from, { text: 'agora enviarei destrava aguarde '}, {quoted:selo})
await sleep(2000);
await pl.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await pl.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await pl.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
await sleep(5000);
await pl.groupSettingUpdate(from, 'not_announcement')
await sleep(2000);
await pl.sendMessage(from, { text: 'Aberto nao marque a trava ou levara ban‚úÖ'}, {quoted:selo})
}

if (body.length >= limitefl) { 
if(!isAntiFlood) return
if(isAntiFlood && isGroupAdmins && isBotGroupAdmins && isPremium) {
if(isBot) return 
reply('*Link detectado, por√©m usu√°rio √© admin*')
} else {
if(isOwner) return
if(isGroupAdmins) return
if(isPremium) return
var Kic = `${sender.split("@")[0]}@s.whatsapp.net`  
setTimeout( () => {
if(!isOwner  && !m.key.fromMe && !isGroupAdmins) return reply('Muitas caracter√≠sticas enviadas, eu afirmo que pode ser trava, por precau√ß√µes, eu irei remover.')
console.log(color('deram Spam','red'))
}, 100)
setTimeout( () => {
pl.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
setTimeout( () => {
}, 0)
}
}

//========================================

hora2 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

uptime = process.uptime()  
/*
if (isCmd) {
uptime = process.uptime()  
sendBtext(from, `
‚ï≠‚îÖ‚ïê‚îÖ‚ïê‚îÖ‚ïê‚îÖ‚ïê‚îÖ‚ïê‚îÖ‚ïê‚îÖ‚ïê·≥Ä
‚îÉ‚ùñ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚û§
‚îÉ‚ùñ‚îÇ
‚îÉ‚ùñ‚îÇ HORA: ${hora2}
‚îÉ‚ùñ‚îÇ·¨äÕ°Õú¬†‚ùì O COMANDO: ${prefix}${command} 
‚îÉ‚ùñ‚îÇ·¨äÕ°Õú¬†‚ÅâÔ∏è N√ÉO EXISTE
‚îÉ‚ùñ‚îÇUSE: ${prefix}menu
‚îÉ‚ùñ‚îÇ
‚îÉ‚ùñ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ï∞‚îÖ‚ïê‚îÖ‚ïê‚îÖ‚ïê‚îÖ‚ïê‚îÖ‚ïê‚îÖ‚ïê‚îÖ‚ïê·≥Ä‚û§`, `TEMPO DO BOT ATIVO:\n ${kyun(uptime)}`,[{buttonId: `${prefix}menu`, buttonText: {displayText: `[ü©∏] OK MANUELA MOSTRA TEU MENU [ü©∏] `}, type: 1}], m) 
}
*/

if (isCmd) {
timestampe = speed();
latensie = speed() - timestampe
uptime = process.uptime()
adivinhaaa = info.key.id.length > 21 ? 'Android ü•¥' : info.key.id.substring(0, 2) == '3A' ? 'IPHONE üîãüîå' : 'ZAP DA WEB üíª';

 reply(`\nOl√° ${pushname}, ${tempo}!\n
O comando: ${command} n√£o existe!\n
digite *${prefix}menu* para ver as op√ß√µes dispon√≠veis!`)
 }
//========================================


if(isCmd) {
if(command == "play" ||
command == "play2" ||
command == "ytmp3" ||
command == "gtts" ||
command == "yta" ||
command == "play3") {
pl.sendPresenceUpdate('recording', from)
} else pl.sendPresenceUpdate('composing', from)
}


//INICIO DE COMANDOS SEM PREFIXO
 switch(testat){
}

if (budy.includes("apagar") || (budy.includes("Apagar") || (budy.includes("apaga") || (budy.includes("apagar") || (budy.includes("Apaga") || (budy.includes("apague"))))))){
if (!isOwner) return
if (!quoted) return
let { chat, fromMe, id } = quoted
pl.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: m.quoted.id, participant: m.quoted.sender } })
}


if (budy.includes("adivinha meu celular") || (budy.includes("Adivinha meu celular") || (budy.includes("Adivinha Meu celular") || (budy.includes("Adivinha Meu Celular") || (budy.includes("bot qual meu celular")))) )){
adivinha = info.key.id.length > 21 ? 'Android ü•¥' : info.key.id.substring(0, 2) == '3A' ? 'IPHONE üîãüîå' : 'ZAP DA WEB üíª';
await pl.sendMessage(from, {text: adivinha}, {quoted: info})
}

/*
if(budy.includes("Prefixo") || budy.includes("prefixo") || budy.includes("Prefix") || budy.includes("prefix")) { 
await  
reply(`O PREFIXO √â: ${prefix}`)
}*/
 
if(budy.match('Boa noite') || budy.includes("Boa Noite") || budy.includes('Boanoite')){
pl.sendMessage(from,{audio: { url: "./audios/boanoite.mp3" }, mimetype: 'audio/mp4' ,ptt: true})
}


//=====================================

switch(ants){
} 

//=========[--ANTI PALAVR√ÉO --]==========\\
if (isGroup && isPalavrao) { //CREDITOS TIAGO
 if (palavra.includes(budy2)) {
 if (!isGroupAdmins) {
 pl.sendMessage(from, {text: `SEM PALAVR√ÉO!! üò†!!`}, {quoted : m})       
setTimeout( () => {
pl.groupParticipantsUpdate(from, [sender], 'remove')
}, 2000)
reply("2")
setTimeout( () => {
reply("1")
}, 1000)
setTimeout( () => {
pl.sendMessage(from, {text: `*„Äå üó£Ô∏èANTI PALAVR√ÉOüó£Ô∏è „Äç*\nVoc√™ ser√° banido do gp, Na proxima tenha √©tica ao falar!!`}, {quoted : m}).catch(e => {
pl.sendMessage(from, {text: `InFelizmente, n√£o sou um administrador, entt n√£o posso te banir!!`}, {quoted : m})
})       			
}, 0)
} else {
return reply(`VOC√ä PODE ${pushname} üòá`)
}
}
}

 
//================(SIMIH-2)=================\\

if (!isCmd && isSimi2 && isGroup) {
if(isCmd || isUrl(budy2)) return
if(budy.length >= 500) return 
if(budy.includes("@55")) return
if (info.key.fromMe) return
if (type == 'extendedTextMessage' && prefix.includes(info.message.extendedTextMessage.contextInfo.quotedMessage.conversation[0])) return
insert(type, info)
const sami = await response(budy)
console.log(sami)

if (sami) pl.sendMessage(from, {text: sami, thumbnail: logo}, {quoted: info});
}


//========================================\\


if (body.startsWith('>')) {
donoprincipal = '557398095072@s.whatsapp.net'
if (!donoprincipal.includes(sender) && !info.key.fromMe) return
try {
console.log('[', color('EVAL', 'silver'),']', color(moment(info.messageTimestamp * 1000).format('DD/MM HH:mm:ss'), 'yellow'), color(budy))
return reply(JSON.stringify(eval(budy.slice(2)),null,'\t')) 
} catch (e) {
reply(e)
}
}

//=====================================


//=====================================

}
} catch (e) {
if(String(e).includes("service-unavailable")) {
console.log(color("Ignore esta mensagem..", "gray"))
} else if(String(e).includes("rate-overlimit")) {
console.log(color("Ignore esta mensagem..", "gray"))
} else if(String(e).includes("at async groupMetadata")) {
console.log(color("Ignore esta mensagem..", "gray"))  
} else if(String(e).includes("Session error")) {
console.log(color("Ignore esta mensagem..", "gray"))
} else if(String(e).includes("rate-overlimit")) {
console.log(color("Ignore esta mensagem..", "gray"))
} else if(String(e).includes("Bad MAC Error")){
console.log(color("Ignore esta mensagem..", "gray"))
} else if(String(e).includes("Key used already or never")) {
console.log(color("Ignore esta mensagem..", "gray"))
} else {
console.log(color(`${e}`, "red"))  
}
}
 


}
